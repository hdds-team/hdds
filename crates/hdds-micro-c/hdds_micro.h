/*
 * HDDS Micro - C FFI Bindings
 * Embedded DDS for microcontrollers (ESP32, RP2040, STM32, Arduino)
 *
 * Auto-generated by cbindgen - DO NOT EDIT
 *
 * Copyright (c) 2025-2026 naskel.com
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 */


#ifndef HDDS_MICRO_H
#define HDDS_MICRO_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes returned by HDDS Micro functions
 */
typedef enum HddsMicroError {
  /**
   * Success (no error)
   */
  HDDS_MICRO_ERROR_OK = 0,
  /**
   * Invalid parameter
   */
  HDDS_MICRO_ERROR_INVALID_PARAMETER = 1,
  /**
   * Buffer too small
   */
  HDDS_MICRO_ERROR_BUFFER_TOO_SMALL = 2,
  /**
   * Transport error
   */
  HDDS_MICRO_ERROR_TRANSPORT_ERROR = 3,
  /**
   * Timeout
   */
  HDDS_MICRO_ERROR_TIMEOUT = 4,
  /**
   * Resource exhausted
   */
  HDDS_MICRO_ERROR_RESOURCE_EXHAUSTED = 5,
  /**
   * Encoding error
   */
  HDDS_MICRO_ERROR_ENCODING_ERROR = 6,
  /**
   * Decoding error
   */
  HDDS_MICRO_ERROR_DECODING_ERROR = 7,
  /**
   * Not initialized
   */
  HDDS_MICRO_ERROR_NOT_INITIALIZED = 8,
  /**
   * Null pointer
   */
  HDDS_MICRO_ERROR_NULL_POINTER = 9,
  /**
   * Unknown error
   */
  HDDS_MICRO_ERROR_UNKNOWN = 255,
} HddsMicroError;

/**
 * Opaque handle to a Transport
 */
typedef struct HddsMicroTransport {
  uint8_t private_[0];
} HddsMicroTransport;

/**
 * UART write callback: write(data, len, user_data) -> bytes_written
 */
typedef int32_t (*UartWriteFn)(const uint8_t*, uintptr_t, void*);

/**
 * UART read callback: read(buf, max_len, timeout_ms, user_data) -> bytes_read
 */
typedef int32_t (*UartReadFn)(uint8_t*, uintptr_t, uint32_t, void*);

/**
 * Opaque handle to a Participant
 */
typedef struct HddsMicroParticipant {
  uint8_t private_[0];
} HddsMicroParticipant;

/**
 * Opaque handle to a Writer
 */
typedef struct HddsMicroWriter {
  uint8_t private_[0];
} HddsMicroWriter;

/**
 * QoS profile for writers/readers
 */
typedef struct HddsMicroQos {
  /**
   * Reliability: 0 = BEST_EFFORT, 1 = RELIABLE
   */
  uint8_t reliability;
  /**
   * History depth (number of samples to keep)
   */
  uint8_t history_depth;
} HddsMicroQos;

/**
 * Opaque handle to a Reader
 */
typedef struct HddsMicroReader {
  uint8_t private_[0];
} HddsMicroReader;

/**
 * Sample info returned when reading data
 */
typedef struct HddsMicroSampleInfo {
  /**
   * Writer GUID prefix (12 bytes)
   */
  uint8_t writer_guid_prefix[12];
  /**
   * Writer entity ID (4 bytes)
   */
  uint8_t writer_entity_id[4];
  /**
   * Sequence number (i64)
   */
  int64_t sequence_number;
  /**
   * Valid data flag (1 if payload contains data)
   */
  uint8_t valid_data;
} HddsMicroSampleInfo;

/**
 * Network locator (address + port)
 */
typedef struct HddsMicroLocator {
  /**
   * Address (IPv4: last 4 bytes, IPv6: all 16 bytes)
   */
  uint8_t address[16];
  /**
   * Port number
   */
  uint32_t port;
} HddsMicroLocator;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get HDDS Micro version string
 */
const char *hdds_micro_version(void);

/**
 * Create a serial transport using callbacks
 *
 * # Safety
 *
 * - `write_fn` and `read_fn` must be valid function pointers
 * - `user_data` will be passed to callbacks, can be NULL
 */
struct HddsMicroTransport *hdds_micro_transport_create_serial(UartWriteFn write_fn,
                                                              UartReadFn read_fn,
                                                              uint8_t node_id,
                                                              void *user_data);

/**
 * Create a null transport (for testing)
 */
struct HddsMicroTransport *hdds_micro_transport_create_null(void);

/**
 * Destroy a transport
 *
 * # Safety
 *
 * - `transport` must be a valid pointer created by `hdds_micro_transport_create_*`
 */
void hdds_micro_transport_destroy(struct HddsMicroTransport *transport);

/**
 * Create a new participant
 *
 * # Safety
 *
 * - `transport` must be a valid pointer created by `hdds_micro_transport_create_*`
 * - Takes ownership of transport (do not destroy transport separately)
 */
struct HddsMicroParticipant *hdds_micro_participant_create(uint32_t domain_id,
                                                           struct HddsMicroTransport *transport);

/**
 * Get participant's domain ID
 */
uint32_t hdds_micro_participant_domain_id(const struct HddsMicroParticipant *participant);

/**
 * Destroy a participant
 *
 * # Safety
 *
 * - `participant` must be a valid pointer created by `hdds_micro_participant_create`
 */
void hdds_micro_participant_destroy(struct HddsMicroParticipant *participant);

/**
 * Create a new writer
 *
 * # Safety
 *
 * - `participant` must be a valid pointer
 * - `topic_name` must be a valid null-terminated string
 */
struct HddsMicroWriter *hdds_micro_writer_create(struct HddsMicroParticipant *participant,
                                                 const char *topic_name,
                                                 const struct HddsMicroQos *qos);

/**
 * Write data
 *
 * # Safety
 *
 * - `writer` must be a valid pointer
 * - `data` must point to `len` bytes of valid data
 */
enum HddsMicroError hdds_micro_write(struct HddsMicroWriter *writer,
                                     const uint8_t *data,
                                     uintptr_t len);

/**
 * Destroy a writer
 */
void hdds_micro_writer_destroy(struct HddsMicroWriter *writer);

/**
 * Create a new reader
 *
 * # Safety
 *
 * - `participant` must be a valid pointer
 * - `topic_name` must be a valid null-terminated string
 */
struct HddsMicroReader *hdds_micro_reader_create(struct HddsMicroParticipant *participant,
                                                 const char *topic_name,
                                                 const struct HddsMicroQos *qos);

/**
 * Read data (non-blocking)
 *
 * Returns HDDS_MICRO_ERROR_OK if data was read, HDDS_MICRO_ERROR_TIMEOUT if no data available.
 * On success, `out_data` contains the payload and `out_len` contains the length.
 * `out_info` is filled with sample metadata if not NULL.
 *
 * # Safety
 *
 * - `reader` must be a valid pointer
 * - `out_data` must point to a buffer of at least `max_len` bytes
 * - `out_len` must be a valid pointer
 */
enum HddsMicroError hdds_micro_read(struct HddsMicroReader *reader,
                                    uint8_t *out_data,
                                    uintptr_t max_len,
                                    uintptr_t *out_len,
                                    struct HddsMicroSampleInfo *out_info);

/**
 * Take data (non-blocking, same as read for BEST_EFFORT)
 *
 * Alias for hdds_micro_read - in embedded BEST_EFFORT mode there's no difference.
 */
enum HddsMicroError hdds_micro_take(struct HddsMicroReader *reader,
                                    uint8_t *out_data,
                                    uintptr_t max_len,
                                    uintptr_t *out_len,
                                    struct HddsMicroSampleInfo *out_info);

/**
 * Get reader's topic name
 *
 * # Safety
 *
 * - `reader` must be a valid pointer
 * - `out_name` must point to a buffer of at least `max_len` bytes
 */
int32_t hdds_micro_reader_topic_name(const struct HddsMicroReader *reader,
                                     char *out_name,
                                     uintptr_t max_len);

/**
 * Destroy a reader
 */
void hdds_micro_reader_destroy(struct HddsMicroReader *reader);

/**
 * Get error code description
 *
 * Returns a static string describing the error code.
 */
const char *hdds_micro_error_str(enum HddsMicroError error);

/**
 * Encode a u8 value
 */
int32_t hdds_micro_encode_u8(uint8_t *buf, uintptr_t buf_len, uint8_t value);

/**
 * Encode a u16 value
 */
int32_t hdds_micro_encode_u16(uint8_t *buf, uintptr_t buf_len, uint16_t value);

/**
 * Encode a u32 value
 */
int32_t hdds_micro_encode_u32(uint8_t *buf, uintptr_t buf_len, uint32_t value);

/**
 * Encode a u64 value
 */
int32_t hdds_micro_encode_u64(uint8_t *buf, uintptr_t buf_len, uint64_t value);

/**
 * Encode a f32 value
 */
int32_t hdds_micro_encode_f32(uint8_t *buf, uintptr_t buf_len, float value);

/**
 * Encode a f64 value
 */
int32_t hdds_micro_encode_f64(uint8_t *buf, uintptr_t buf_len, double value);

/**
 * Encode bytes (raw data)
 */
int32_t hdds_micro_encode_bytes(uint8_t *buf,
                                uintptr_t buf_len,
                                const uint8_t *data,
                                uintptr_t data_len);

/**
 * Encode an i8 value
 */
int32_t hdds_micro_encode_i8(uint8_t *buf, uintptr_t buf_len, int8_t value);

/**
 * Encode an i16 value
 */
int32_t hdds_micro_encode_i16(uint8_t *buf, uintptr_t buf_len, int16_t value);

/**
 * Encode an i32 value
 */
int32_t hdds_micro_encode_i32(uint8_t *buf, uintptr_t buf_len, int32_t value);

/**
 * Encode an i64 value
 */
int32_t hdds_micro_encode_i64(uint8_t *buf, uintptr_t buf_len, int64_t value);

/**
 * Encode a bool value
 */
int32_t hdds_micro_encode_bool(uint8_t *buf, uintptr_t buf_len, bool value);

/**
 * Encode a string (length-prefixed with null terminator)
 *
 * # Safety
 *
 * - `str_ptr` must be a valid null-terminated string
 */
int32_t hdds_micro_encode_string(uint8_t *buf, uintptr_t buf_len, const char *str_ptr);

/**
 * Decode a u8 value
 */
int32_t hdds_micro_decode_u8(const uint8_t *buf, uintptr_t buf_len, uint8_t *out_value);

/**
 * Decode a u16 value
 */
int32_t hdds_micro_decode_u16(const uint8_t *buf, uintptr_t buf_len, uint16_t *out_value);

/**
 * Decode a u32 value
 */
int32_t hdds_micro_decode_u32(const uint8_t *buf, uintptr_t buf_len, uint32_t *out_value);

/**
 * Decode a f32 value
 */
int32_t hdds_micro_decode_f32(const uint8_t *buf, uintptr_t buf_len, float *out_value);

/**
 * Decode a u64 value
 */
int32_t hdds_micro_decode_u64(const uint8_t *buf, uintptr_t buf_len, uint64_t *out_value);

/**
 * Decode an i8 value
 */
int32_t hdds_micro_decode_i8(const uint8_t *buf, uintptr_t buf_len, int8_t *out_value);

/**
 * Decode an i16 value
 */
int32_t hdds_micro_decode_i16(const uint8_t *buf, uintptr_t buf_len, int16_t *out_value);

/**
 * Decode an i32 value
 */
int32_t hdds_micro_decode_i32(const uint8_t *buf, uintptr_t buf_len, int32_t *out_value);

/**
 * Decode an i64 value
 */
int32_t hdds_micro_decode_i64(const uint8_t *buf, uintptr_t buf_len, int64_t *out_value);

/**
 * Decode an f64 value
 */
int32_t hdds_micro_decode_f64(const uint8_t *buf, uintptr_t buf_len, double *out_value);

/**
 * Decode a bool value
 */
int32_t hdds_micro_decode_bool(const uint8_t *buf, uintptr_t buf_len, bool *out_value);

/**
 * Decode a string (length-prefixed with null terminator)
 *
 * Copies the decoded string into `out_str` buffer and null-terminates it.
 * Returns the number of bytes consumed from `buf`, or -1 on error.
 *
 * # Safety
 *
 * - `out_str` must point to a buffer of at least `max_len` bytes
 */
int32_t hdds_micro_decode_string(const uint8_t *buf,
                                 uintptr_t buf_len,
                                 char *out_str,
                                 uintptr_t max_len);

/**
 * Decode raw bytes
 *
 * Copies `count` bytes from `buf` into `out_data`.
 * Returns the number of bytes consumed, or -1 on error.
 *
 * # Safety
 *
 * - `out_data` must point to a buffer of at least `count` bytes
 */
int32_t hdds_micro_decode_bytes(const uint8_t *buf,
                                uintptr_t buf_len,
                                uint8_t *out_data,
                                uintptr_t count);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* HDDS_MICRO_H */
