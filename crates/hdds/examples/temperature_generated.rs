// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com
//
// This file is included as a module by rti_temperature_subscriber_idlgen.rs
// It can also be run standalone to verify the generated types compile.
//
// Generated by idl_parser v0.2.0
// DO NOT EDIT

#![allow(dead_code, clippy::all, non_snake_case)]

// Generated by idl-gen from RTI Temperature.idl
// Manual cleanup: Removed Vec/HashMap impls (belong in hdds crate)

use hdds::{Cdr2Decode, Cdr2Encode, CdrError};

pub mod TemperatureData {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct Temperature {
        pub value: f32,
        pub timestamp: i32,
    }

    impl Cdr2Encode for Temperature {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;

            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;

            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset + 4].copy_from_slice(&self.value.to_le_bytes());
            offset += 4;

            // Align to 4-byte boundary for field 'timestamp'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;

            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset + 4].copy_from_slice(&self.timestamp.to_le_bytes());
            offset += 4;

            Ok(offset)
        }

        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 3 + 4
        }
    }

    impl Cdr2Decode for Temperature {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;

            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;

            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let value = f32::from_le_bytes(
                src[offset..offset + 4]
                    .try_into()
                    .expect("slice length checked"),
            );
            offset += 4;

            // Align to 4-byte boundary for field 'timestamp'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;

            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp = i32::from_le_bytes(
                src[offset..offset + 4]
                    .try_into()
                    .expect("slice length checked"),
            );
            offset += 4;

            Ok((Self { value, timestamp }, offset))
        }
    }

    // === DDS Trait (auto-generated by idl-gen) ===
    impl ::hdds::api::DDS for Temperature {
        fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
            static DESC: ::hdds::core::types::TypeDescriptor =
                ::hdds::core::types::TypeDescriptor {
                    type_id: 0x05644EB5, // FNV-1a hash of "TemperatureData::Temperature"
                    type_name: "TemperatureData::Temperature",
                    size_bytes: 8,
                    alignment: 4,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "value",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32,
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp",
                            offset_bytes: 4,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I32,
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
            &DESC
        }

        fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::dds::Result<usize> {
            use ::hdds::core::ser::Cdr2Encode;
            self.encode_cdr2_le(buf).map_err(|e| match e {
                ::hdds::CdrError::BufferTooSmall => ::hdds::Error::BufferTooSmall,
                _ => ::hdds::Error::SerializationError,
            })
        }

        fn decode_cdr2(buf: &[u8]) -> ::hdds::dds::Result<Self> {
            use ::hdds::core::ser::Cdr2Decode;
            Self::decode_cdr2_le(buf)
                .map(|(val, _)| val)
                .map_err(|e| match e {
                    ::hdds::CdrError::UnexpectedEof => ::hdds::Error::EndianMismatch,
                    _ => ::hdds::Error::SerializationError,
                })
        }

        fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
            Some(::hdds::xtypes::CompleteTypeObject::Struct(
                ::hdds::xtypes::CompleteStructType {
                    struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                    header: ::hdds::xtypes::CompleteStructHeader {
                        base_type: None,
                        detail: ::hdds::xtypes::CompleteTypeDetail::new(
                            "TemperatureData::Temperature",
                        ),
                    },
                    member_seq: vec![
                        ::hdds::xtypes::CompleteStructMember {
                            common: ::hdds::xtypes::CommonStructMember {
                                member_id: 0,
                                member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                            },
                            detail: ::hdds::xtypes::CompleteMemberDetail::new("value"),
                        },
                        ::hdds::xtypes::CompleteStructMember {
                            common: ::hdds::xtypes::CommonStructMember {
                                member_id: 1,
                                member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT32,
                            },
                            detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp"),
                        },
                    ],
                },
            ))
        }
    }
}

fn main() {
    // This file primarily provides the Temperature type for rti_temperature_subscriber_idlgen.rs
    // Running standalone just verifies the type definitions compile correctly.
    use TemperatureData::Temperature;
    let sample = Temperature {
        value: 23.5,
        timestamp: 1234567890,
    };
    println!("Temperature type compiled OK: {:?}", sample);
}
