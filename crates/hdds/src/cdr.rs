// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

//! # CDR2 Serialization
//!
//! This module provides the CDR2 (Common Data Representation v2) serialization
//! traits used for DDS wire-format encoding/decoding.
//!
//! ## Overview
//!
//! CDR2 is the standard binary wire format for DDS/RTPS messages, specified in
//! OMG DDS-RTPS v2.5. It defines:
//!
//! - **Little-endian** byte ordering (mandatory for RTPS v2.3+)
//! - **Alignment rules** for primitive types
//! - **String encoding** with null terminator
//! - **Sequence encoding** with length prefix
//!
//! ## Usage
//!
//! Types that implement `Cdr2Encode + Cdr2Decode` can be used with DDS:
//!
//! ```rust,ignore
//! use hdds::{Participant, QoS, DDS};
//!
//! #[derive(DDS)]  // Generates Cdr2Encode + Cdr2Decode
//! struct SensorData {
//!     id: u32,
//!     value: f32,
//! }
//!
//! let writer = participant.create_writer::<SensorData>("topic", QoS::default())?;
//! ```
//!
//! ## Wire Format Example
//!
//! ```text
//! struct { u32 id; f32 value; }
//!
//! Encoded (8 bytes, little-endian):
//! +----------------+----------------+
//! |  id (4 bytes)  | value (4 bytes)|
//! | 2A 00 00 00    | DB 0F 49 40    |  (id=42, value=3.14159)
//! +----------------+----------------+
//! ```
//!
//! ## See Also
//!
//! - [`DDS`](crate::dds::DDS) - Main trait combining serialization + metadata
//! - [RTPS v2.5 Sec.10](https://www.omg.org/spec/DDSI-RTPS/2.5/) - CDR Representation

/// CDR2 (Common Data Representation) serialization traits
///
/// Implements OMG DDS-RTPS v2.5 CDR2 Little Endian wire format.
/// Generated by build.rs from IDL schemas.
///
/// # Wire Format
///
/// CDR2 uses little-endian encoding with alignment rules:
/// - Primitives: aligned to their size (u32 -> 4-byte boundary)
/// - Strings: `[u32 len][UTF-8 bytes]['\0']` (len excludes null terminator)
/// - Sequences: `[u32 count][elements...]`
///
/// # Safety
///
/// All encode/decode operations are bounds-checked and fallible.
/// Buffer overflow returns `CdrError::BufferTooSmall`.
///
/// # Examples
///
/// ```no_run
/// use hdds::cdr::{Cdr2Encode, Cdr2Decode, CdrError};
///
/// // Example generated struct (from temperature.idl)
/// #[derive(Debug, Clone)]
/// struct Temperature {
///     value: f32,
/// }
///
/// impl Cdr2Encode for Temperature {
///     fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
///         if dst.len() < 4 {
///             return Err(CdrError::BufferTooSmall);
///         }
///         dst[0..4].copy_from_slice(&self.value.to_le_bytes());
///         Ok(4)
///     }
///
///     fn max_cdr2_size(&self) -> usize {
///         4
///     }
/// }
///
/// impl Cdr2Decode for Temperature {
///     fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
///         if src.len() < 4 {
///             return Err(CdrError::UnexpectedEof);
///         }
///         let value = f32::from_le_bytes(src[0..4].try_into().expect("slice length checked"));
///         Ok((Self { value }, 4))
///     }
/// }
/// ```
/// CDR encoding/decoding errors
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CdrError {
    /// Destination buffer too small for encoding
    BufferTooSmall,
    /// Invalid encoding format (e.g., bad UTF-8)
    InvalidEncoding,
    /// Unexpected end of source buffer during decoding
    UnexpectedEof,
}

impl std::fmt::Display for CdrError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CdrError::BufferTooSmall => write!(f, "CDR buffer too small"),
            CdrError::InvalidEncoding => write!(f, "Invalid CDR encoding"),
            CdrError::UnexpectedEof => write!(f, "Unexpected end of CDR buffer"),
        }
    }
}

impl std::error::Error for CdrError {}

/// CDR2 Little Endian encoding trait
///
/// Auto-generated by build.rs for IDL-defined types.
/// Encodes structs into CDR2 wire format with alignment.
///
/// # Examples
///
/// ```no_run
/// use hdds::cdr::{Cdr2Encode, CdrError};
///
/// struct MyData {
///     id: u32,
///     value: f32,
/// }
///
/// impl Cdr2Encode for MyData {
///     fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
///         if dst.len() < 8 {
///             return Err(CdrError::BufferTooSmall);
///         }
///         dst[0..4].copy_from_slice(&self.id.to_le_bytes());
///         dst[4..8].copy_from_slice(&self.value.to_le_bytes());
///         Ok(8)
///     }
///
///     fn max_cdr2_size(&self) -> usize {
///         8 // u32 (4) + f32 (4)
///     }
/// }
/// ```
pub trait Cdr2Encode {
    /// Encode instance into CDR2 little-endian format
    ///
    /// # Arguments
    ///
    /// - `dst`: Destination buffer (must be >= `max_cdr2_size()`)
    ///
    /// # Returns
    ///
    /// - `Ok(bytes_written)` on success
    /// - `Err(CdrError::BufferTooSmall)` if dst too small
    ///
    /// # Errors
    ///
    /// Returns `CdrError::BufferTooSmall` if the destination buffer is too small.
    ///
    /// # Alignment
    ///
    /// Caller must ensure dst has proper alignment for CDR2 encoding.
    /// Generated impls handle field-level alignment automatically.
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError>;

    /// Maximum encoded size in bytes (worst-case)
    ///
    /// Used for stack buffer allocation before `encode()`.
    /// Includes padding for alignment.
    fn max_cdr2_size(&self) -> usize;
}

/// CDR2 Little Endian decoding trait
///
/// Auto-generated by build.rs for IDL-defined types.
/// Decodes CDR2 wire format into Rust structs.
///
/// # Examples
///
/// ```no_run
/// use hdds::cdr::{Cdr2Decode, CdrError};
///
/// struct MyData {
///     id: u32,
///     value: f32,
/// }
///
/// impl Cdr2Decode for MyData {
///     fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
///         if src.len() < 8 {
///             return Err(CdrError::UnexpectedEof);
///         }
///         let id = u32::from_le_bytes(src[0..4].try_into().expect("slice length checked"));
///         let value = f32::from_le_bytes(src[4..8].try_into().expect("slice length checked"));
///         Ok((Self { id, value }, 8))
///     }
/// }
/// ```
pub trait Cdr2Decode: Sized {
    /// Decode instance from CDR2 little-endian format
    ///
    /// # Arguments
    ///
    /// - `src`: Source buffer containing CDR2-encoded data
    ///
    /// # Returns
    ///
    /// - `Ok((decoded_instance, bytes_consumed))` on success
    /// - `Err(CdrError::UnexpectedEof)` if src truncated
    /// - `Err(CdrError::InvalidEncoding)` if data invalid (bad UTF-8, etc.)
    ///
    /// # Errors
    ///
    /// Returns `CdrError::UnexpectedEof` if the source buffer is truncated,
    /// or `CdrError::InvalidEncoding` if data is invalid.
    ///
    /// # Safety
    ///
    /// All bounds checks are performed. No unsafe operations.
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError>;
}

/// Marker trait for DDS-compatible types
///
/// Automatically implemented for all types that have both `Cdr2Encode` and `Cdr2Decode`.
/// Used as trait bound for `DataWriter<T>`/`DataReader<T>`.
///
/// # Examples
///
/// ```ignore
/// use hdds::cdr::DDS;
///
/// // Temperature type with Cdr2Encode + Cdr2Decode already implemented
/// // (e.g., by #[derive(hdds::DDS)] or generated by build.rs)
///
/// // DDS trait is automatically implemented via blanket impl
/// // (no manual impl needed)
///
/// // Usage in API:
/// fn create_writer<T: DDS>() { /* ... */ }
/// ```
pub trait DDS: Cdr2Encode + Cdr2Decode + Send + Sync + 'static {}

// Blanket impl: any type with Encode + Decode is DDS-compatible
impl<T> DDS for T where T: Cdr2Encode + Cdr2Decode + Send + Sync + 'static {}

#[cfg(test)]
mod tests {
    use super::*;
    const TEST_VALUE: f32 = std::f32::consts::PI;

    // Mock struct for testing
    #[derive(Debug, Clone, PartialEq)]
    struct TestStruct {
        id: u32,
        value: f32,
    }

    impl Cdr2Encode for TestStruct {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            if dst.len() < 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[0..4].copy_from_slice(&self.id.to_le_bytes());
            dst[4..8].copy_from_slice(&self.value.to_le_bytes());
            Ok(8)
        }

        fn max_cdr2_size(&self) -> usize {
            8
        }
    }

    impl Cdr2Decode for TestStruct {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            if src.len() < 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let id = u32::from_le_bytes(src[0..4].try_into().expect("slice length checked above"));
            let value =
                f32::from_le_bytes(src[4..8].try_into().expect("slice length checked above"));
            Ok((Self { id, value }, 8))
        }
    }

    #[test]
    fn test_encode() {
        let data = TestStruct {
            id: 42,
            value: TEST_VALUE,
        };

        let mut buf = vec![0u8; 8];
        let written = data
            .encode_cdr2_le(&mut buf)
            .expect("encode should succeed with sufficient buffer");

        assert_eq!(written, 8);
        assert_eq!(&buf[0..4], &42u32.to_le_bytes());
        assert_eq!(&buf[4..8], &TEST_VALUE.to_le_bytes());
    }

    #[test]
    #[allow(clippy::float_cmp)] // Test constants, exact equality is intentional
    fn test_decode() {
        let mut buf = vec![0u8; 8];
        buf[0..4].copy_from_slice(&42u32.to_le_bytes());
        buf[4..8].copy_from_slice(&TEST_VALUE.to_le_bytes());

        let (decoded, used) =
            TestStruct::decode_cdr2_le(&buf).expect("decode should succeed with valid buffer");

        assert_eq!(decoded.id, 42);
        assert_eq!(decoded.value, TEST_VALUE);
        assert_eq!(used, 8);
    }

    #[test]
    fn test_roundtrip() {
        let original = TestStruct {
            id: 123,
            value: 456.789,
        };

        let mut buf = vec![0u8; 8];
        original
            .encode_cdr2_le(&mut buf)
            .expect("encode should succeed");

        let (decoded, _used) = TestStruct::decode_cdr2_le(&buf).expect("decode should succeed");

        assert_eq!(original, decoded);
    }

    #[test]
    fn test_encode_buffer_too_small() {
        let data = TestStruct {
            id: 42,
            value: TEST_VALUE,
        };

        let mut buf = vec![0u8; 4]; // Too small
        let result = data.encode_cdr2_le(&mut buf);

        assert_eq!(result, Err(CdrError::BufferTooSmall));
    }

    #[test]
    fn test_decode_unexpected_eof() {
        let buf = vec![0u8; 4]; // Too small
        let result = TestStruct::decode_cdr2_le(&buf);

        assert_eq!(result, Err(CdrError::UnexpectedEof));
    }

    #[test]
    fn test_max_size() {
        let data = TestStruct { id: 0, value: 0.0 };

        assert_eq!(data.max_cdr2_size(), 8);
    }

    #[test]
    fn test_dds_trait_impl() {
        // TestStruct should auto-impl DDS trait
        fn assert_dds<T: DDS>() {}
        assert_dds::<TestStruct>();
    }

    #[test]
    fn test_cdr_error_display() {
        assert_eq!(
            format!("{}", CdrError::BufferTooSmall),
            "CDR buffer too small"
        );
        assert_eq!(
            format!("{}", CdrError::InvalidEncoding),
            "Invalid CDR encoding"
        );
        assert_eq!(
            format!("{}", CdrError::UnexpectedEof),
            "Unexpected end of CDR buffer"
        );
    }
}
