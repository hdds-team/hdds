// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

//! CDR2 encoding/decoding traits
//!
//! These traits define the interface for types that can be serialized/deserialized
//! using CDR2 (Common Data Representation v2) format.
//!
//! These traits are designed to match the output of hdds_gen (IDL code generator),
//! allowing seamless integration between generated types and HDDS runtime.

use std::fmt;

/// Error type for CDR2 encoding/decoding operations
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CdrError {
    /// Output buffer too small for encoded data
    BufferTooSmall,

    /// Unexpected end of input buffer during decoding
    UnexpectedEof,

    /// Invalid UTF-8 encoding in string field
    InvalidEncoding,

    /// Invalid CDR2 magic bytes in header
    InvalidMagic,

    /// Data exceeds maximum encodable size (> u32::MAX bytes)
    DataTooLarge,

    /// Other error with custom message
    Other(String),
}

impl fmt::Display for CdrError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CdrError::BufferTooSmall => write!(f, "Buffer too small for CDR2 encoding"),
            CdrError::UnexpectedEof => write!(f, "Unexpected end of buffer during CDR2 decoding"),
            CdrError::InvalidEncoding => write!(f, "Invalid UTF-8 encoding in string field"),
            CdrError::InvalidMagic => write!(f, "Invalid CDR2 magic bytes"),
            CdrError::DataTooLarge => write!(f, "Data exceeds maximum encodable size (> 4GB)"),
            CdrError::Other(msg) => write!(f, "CDR2 error: {}", msg),
        }
    }
}

impl std::error::Error for CdrError {}

/// Convert CdrError to crate::Error for API compatibility
impl From<CdrError> for crate::Error {
    fn from(e: CdrError) -> Self {
        match e {
            CdrError::BufferTooSmall => crate::Error::BufferTooSmall,
            CdrError::UnexpectedEof
            | CdrError::InvalidEncoding
            | CdrError::InvalidMagic
            | CdrError::DataTooLarge
            | CdrError::Other(_) => crate::Error::SerializationError,
        }
    }
}

/// CDR2 encoding trait (Little-Endian)
///
/// Types implementing this trait can be serialized to CDR2 wire format.
/// This trait is typically implemented by hdds_gen code generator.
///
/// # Example (generated by hdds_gen)
///
/// ```ignore
/// impl Cdr2Encode for Point {
///     fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
///         let mut offset = 0;
///         // Write fields with proper alignment...
///         Ok(offset)
///     }
///
///     fn max_cdr2_size(&self) -> usize {
///         // Conservative size estimate
///         24
///     }
/// }
/// ```
pub trait Cdr2Encode {
    /// Encode this value into CDR2 Little-Endian format
    ///
    /// # Arguments
    /// * `dst` - Output buffer (must be large enough, check with `max_cdr2_size()`)
    ///
    /// # Returns
    /// Number of bytes written, or `CdrError::BufferTooSmall` if buffer too small
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError>;

    /// Get maximum size in bytes for CDR2 encoding
    ///
    /// This is a conservative estimate (may include padding/alignment overhead).
    /// Variable-size types (strings, sequences) should use worst-case estimates.
    fn max_cdr2_size(&self) -> usize;
}

/// CDR2 decoding trait (Little-Endian)
///
/// Types implementing this trait can be deserialized from CDR2 wire format.
/// This trait is typically implemented by hdds_gen code generator.
///
/// # Example (generated by hdds_gen)
///
/// ```ignore
/// impl Cdr2Decode for Point {
///     fn decode_cdr2_le(src: &[u8]) -> Result<Self, CdrError> {
///         let mut offset = 0;
///         // Read fields with proper alignment...
///         Ok(Point { x, y })
///     }
/// }
/// ```
pub trait Cdr2Decode: Sized {
    /// Decode a value from CDR2 Little-Endian format
    ///
    /// # Arguments
    /// * `src` - Input buffer containing CDR2-encoded data
    ///
    /// # Returns
    /// Tuple of (decoded value, bytes consumed), or `CdrError` on failure
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError>;
}

// DDS trait is defined in crate::dds::DDS (with type_descriptor, encode_cdr2, decode_cdr2)
// We provide Cdr2Encode/Cdr2Decode as lower-level traits that hdds_gen generates.
// A blanket impl in api/mod.rs bridges Cdr2Encode/Cdr2Decode -> api::DDS.

// ============================================================================
// Standard Type Implementations
// ============================================================================

/// CDR2 encoding for String
///
/// CDR2 string format:
/// - u32 length (number of characters, NOT including null terminator)
/// - UTF-8 bytes
/// - null terminator (0x00)
impl Cdr2Encode for String {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let bytes = self.as_bytes();
        let len = bytes.len();

        // CDR uses u32 for string length - reject strings > 4GB
        let len_u32: u32 = len.try_into().map_err(|_| CdrError::DataTooLarge)?;

        let total_size = 4 + len + 1; // length prefix + bytes + null terminator

        if dst.len() < total_size {
            return Err(CdrError::BufferTooSmall);
        }

        // Write length (u32 LE)
        dst[0..4].copy_from_slice(&len_u32.to_le_bytes());
        // Write string bytes
        dst[4..4 + len].copy_from_slice(bytes);
        // Write null terminator
        dst[4 + len] = 0;

        Ok(total_size)
    }

    fn max_cdr2_size(&self) -> usize {
        4 + self.len() + 1
    }
}

/// CDR2 decoding for String
impl Cdr2Decode for String {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        if src.len() < 4 {
            return Err(CdrError::UnexpectedEof);
        }

        // Read length
        #[allow(clippy::unwrap_used)] // src[0..4] is exactly 4 bytes, checked above
        let len = u32::from_le_bytes(src[0..4].try_into().unwrap()) as usize;
        let total_size = 4usize.saturating_add(len).saturating_add(1);

        if src.len() < total_size {
            return Err(CdrError::UnexpectedEof);
        }

        // Read string bytes (without null terminator)
        let s = std::str::from_utf8(&src[4..4 + len])
            .map_err(|_| CdrError::InvalidEncoding)?
            .to_string();

        Ok((s, total_size))
    }
}

// ============================================================================
// Primitive Type Implementations
// ============================================================================

macro_rules! impl_cdr2_primitive {
    ($ty:ty, $size:expr) => {
        impl Cdr2Encode for $ty {
            fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
                if dst.len() < $size {
                    return Err(CdrError::BufferTooSmall);
                }
                dst[..$size].copy_from_slice(&self.to_le_bytes());
                Ok($size)
            }
            fn max_cdr2_size(&self) -> usize {
                $size
            }
        }

        impl Cdr2Decode for $ty {
            fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
                if src.len() < $size {
                    return Err(CdrError::UnexpectedEof);
                }
                let mut bytes = [0u8; $size];
                bytes.copy_from_slice(&src[..$size]);
                Ok((<$ty>::from_le_bytes(bytes), $size))
            }
        }
    };
}

impl_cdr2_primitive!(i8, 1);
impl_cdr2_primitive!(u8, 1);
impl_cdr2_primitive!(i16, 2);
impl_cdr2_primitive!(u16, 2);
impl_cdr2_primitive!(i32, 4);
impl_cdr2_primitive!(u32, 4);
impl_cdr2_primitive!(i64, 8);
impl_cdr2_primitive!(u64, 8);
impl_cdr2_primitive!(f32, 4);
impl_cdr2_primitive!(f64, 8);

// ============================================================================
// Vec<T> Implementation
// ============================================================================

impl<T: Cdr2Encode> Cdr2Encode for Vec<T> {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset = 0;

        // Write sequence length (u32)
        let len = self.len() as u32;
        if dst.len() < 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset + 4].copy_from_slice(&len.to_le_bytes());
        offset += 4;

        // Write each element
        for elem in self {
            let used = elem.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
        }

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        // Conservative estimate: 4 bytes for length + sum of element sizes
        4 + self.iter().map(|e| e.max_cdr2_size()).sum::<usize>()
    }
}

impl<T: Cdr2Decode> Cdr2Decode for Vec<T> {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset = 0;

        // Read sequence length
        if src.len() < 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = u32::from_le_bytes([src[0], src[1], src[2], src[3]]) as usize;
        offset += 4;

        // Guard against bogus lengths: each element is at least 1 byte
        if len > src.len().saturating_sub(offset) {
            return Err(CdrError::UnexpectedEof);
        }

        // Read elements
        let mut vec = Vec::with_capacity(len);
        for _ in 0..len {
            let (elem, used) = T::decode_cdr2_le(&src[offset..])?;
            vec.push(elem);
            offset += used;
        }

        Ok((vec, offset))
    }
}

// ============================================================================
// HashMap<K, V> Implementation
// ============================================================================

impl<K: Cdr2Encode, V: Cdr2Encode> Cdr2Encode for std::collections::HashMap<K, V> {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset = 0;

        // Write map length (u32)
        let len = self.len() as u32;
        if dst.len() < 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset + 4].copy_from_slice(&len.to_le_bytes());
        offset += 4;

        // Write each key-value pair
        for (key, value) in self {
            let used = key.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
            let used = value.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
        }

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        // Conservative estimate
        4 + self.len() * 64 // rough estimate per entry
    }
}

impl<K, V> Cdr2Decode for std::collections::HashMap<K, V>
where
    K: Cdr2Decode + std::cmp::Eq + std::hash::Hash,
    V: Cdr2Decode,
{
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset = 0;

        // Read map length
        if src.len() < 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = u32::from_le_bytes([src[0], src[1], src[2], src[3]]) as usize;
        offset += 4;

        // Guard against bogus lengths: each KV pair is at least 2 bytes
        if len > src.len().saturating_sub(offset) / 2 {
            return Err(CdrError::UnexpectedEof);
        }

        // Read key-value pairs
        let mut map = std::collections::HashMap::with_capacity(len);
        for _ in 0..len {
            let (key, used) = K::decode_cdr2_le(&src[offset..])?;
            offset += used;
            let (value, used) = V::decode_cdr2_le(&src[offset..])?;
            offset += used;
            map.insert(key, value);
        }

        Ok((map, offset))
    }
}

/// CDR2 encoding for &str (borrows to String encoding)
impl Cdr2Encode for &str {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let bytes = self.as_bytes();
        let len = bytes.len();

        // CDR uses u32 for string length - reject strings > 4GB
        let len_u32: u32 = len.try_into().map_err(|_| CdrError::DataTooLarge)?;

        let total_size = 4 + len + 1;

        if dst.len() < total_size {
            return Err(CdrError::BufferTooSmall);
        }

        dst[0..4].copy_from_slice(&len_u32.to_le_bytes());
        dst[4..4 + len].copy_from_slice(bytes);
        dst[4 + len] = 0;

        Ok(total_size)
    }

    fn max_cdr2_size(&self) -> usize {
        4 + self.len() + 1
    }
}

// ============================================================================
// bool Implementation (XTypes 1.3 Section 7.4.1.3)
// CDR2 boolean: 1 byte, 0x00 = false, 0x01 = true
// ============================================================================

impl Cdr2Encode for bool {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        if dst.is_empty() {
            return Err(CdrError::BufferTooSmall);
        }
        dst[0] = u8::from(*self);
        Ok(1)
    }
    fn max_cdr2_size(&self) -> usize {
        1
    }
}

impl Cdr2Decode for bool {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        if src.is_empty() {
            return Err(CdrError::UnexpectedEof);
        }
        match src[0] {
            0 => Ok((false, 1)),
            1 => Ok((true, 1)),
            v => Err(CdrError::Other(format!("invalid boolean value: {v}"))),
        }
    }
}

// ============================================================================
// char Implementation (XTypes 1.3 Section 7.4.1.4 -- char8 only)
// CDR2 char8: 1 byte, ASCII range
// ============================================================================

impl Cdr2Encode for char {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        if dst.is_empty() {
            return Err(CdrError::BufferTooSmall);
        }
        // char8 is a single ASCII byte per spec
        if !self.is_ascii() {
            return Err(CdrError::InvalidEncoding);
        }
        dst[0] = *self as u8;
        Ok(1)
    }
    fn max_cdr2_size(&self) -> usize {
        1
    }
}

impl Cdr2Decode for char {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        if src.is_empty() {
            return Err(CdrError::UnexpectedEof);
        }
        // char8: any byte value maps to a char (ASCII subset per spec,
        // but we accept the full u8 range for interop tolerance)
        Ok((src[0] as char, 1))
    }
}

// ============================================================================
// [T; N] Implementation (XTypes 1.3 Section 7.4.4.2 -- fixed-size array)
// CDR2 array: N elements encoded sequentially, NO length prefix
// ============================================================================

impl<T: Cdr2Encode, const N: usize> Cdr2Encode for [T; N] {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset = 0;
        for elem in self {
            let n = elem.encode_cdr2_le(&mut dst[offset..])?;
            offset += n;
        }
        Ok(offset)
    }
    fn max_cdr2_size(&self) -> usize {
        self.iter().map(|e| e.max_cdr2_size()).sum()
    }
}

impl<T: Cdr2Decode + Default + Copy, const N: usize> Cdr2Decode for [T; N] {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut arr = [T::default(); N];
        let mut offset = 0;
        for slot in &mut arr {
            let (val, n) = T::decode_cdr2_le(&src[offset..])?;
            *slot = val;
            offset += n;
        }
        Ok((arr, offset))
    }
}

// ============================================================================
// Option<T> Implementation (XTypes 1.3 Section 7.4.3.5 -- optional member)
// CDR2 optional: 1-byte presence flag (0x00 absent, 0x01 present) + value
// ============================================================================

impl<T: Cdr2Encode> Cdr2Encode for Option<T> {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        if dst.is_empty() {
            return Err(CdrError::BufferTooSmall);
        }
        match self {
            None => {
                dst[0] = 0;
                Ok(1)
            }
            Some(val) => {
                dst[0] = 1;
                let n = val.encode_cdr2_le(&mut dst[1..])?;
                Ok(1 + n)
            }
        }
    }
    fn max_cdr2_size(&self) -> usize {
        match self {
            None => 1,
            Some(val) => 1 + val.max_cdr2_size(),
        }
    }
}

impl<T: Cdr2Decode> Cdr2Decode for Option<T> {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        if src.is_empty() {
            return Err(CdrError::UnexpectedEof);
        }
        match src[0] {
            0 => Ok((None, 1)),
            1 => {
                let (val, n) = T::decode_cdr2_le(&src[1..])?;
                Ok((Some(val), 1 + n))
            }
            v => Err(CdrError::Other(format!("invalid optional flag: {v}"))),
        }
    }
}

// ============================================================================
// BTreeMap<K, V> Implementation
// Same wire format as HashMap: u32 length + sequence of (K, V) pairs.
// Deterministic iteration order (sorted by key).
// ============================================================================

impl<K: Cdr2Encode + Ord, V: Cdr2Encode> Cdr2Encode for std::collections::BTreeMap<K, V> {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        if dst.len() < 4 {
            return Err(CdrError::BufferTooSmall);
        }
        let len = self.len() as u32;
        dst[0..4].copy_from_slice(&len.to_le_bytes());
        let mut offset = 4;
        for (key, value) in self {
            let n = key.encode_cdr2_le(&mut dst[offset..])?;
            offset += n;
            let n = value.encode_cdr2_le(&mut dst[offset..])?;
            offset += n;
        }
        Ok(offset)
    }
    fn max_cdr2_size(&self) -> usize {
        4 + self.len() * 64
    }
}

impl<K, V> Cdr2Decode for std::collections::BTreeMap<K, V>
where
    K: Cdr2Decode + Ord,
    V: Cdr2Decode,
{
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        if src.len() < 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = u32::from_le_bytes([src[0], src[1], src[2], src[3]]) as usize;
        let mut offset = 4;
        if len > src.len().saturating_sub(offset) / 2 {
            return Err(CdrError::UnexpectedEof);
        }
        let mut map = std::collections::BTreeMap::new();
        for _ in 0..len {
            let (key, n) = K::decode_cdr2_le(&src[offset..])?;
            offset += n;
            let (value, n) = V::decode_cdr2_le(&src[offset..])?;
            offset += n;
            map.insert(key, value);
        }
        Ok((map, offset))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test struct implementing CDR2 traits manually
    #[derive(Debug, Clone, PartialEq)]
    struct TestPoint {
        x: i32,
        y: i32,
    }

    impl Cdr2Encode for TestPoint {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            if dst.len() < 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[0..4].copy_from_slice(&self.x.to_le_bytes());
            dst[4..8].copy_from_slice(&self.y.to_le_bytes());
            Ok(8)
        }

        fn max_cdr2_size(&self) -> usize {
            8
        }
    }

    impl Cdr2Decode for TestPoint {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            if src.len() < 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let x = i32::from_le_bytes(src[0..4].try_into().map_err(|_| CdrError::UnexpectedEof)?);
            let y = i32::from_le_bytes(src[4..8].try_into().map_err(|_| CdrError::UnexpectedEof)?);
            Ok((TestPoint { x, y }, 8))
        }
    }

    #[test]
    fn test_cdr2_encode_decode_roundtrip() {
        let point = TestPoint { x: 42, y: 123 };
        let mut buf = vec![0u8; 256];

        // Encode
        let encoded_len = point
            .encode_cdr2_le(&mut buf)
            .expect("Encode should succeed");
        assert_eq!(encoded_len, 8);

        // Decode
        let (decoded, used) =
            TestPoint::decode_cdr2_le(&buf[..encoded_len]).expect("Decode should succeed");
        assert_eq!(decoded, point);
        assert_eq!(used, 8);
    }

    #[test]
    fn test_buffer_too_small() {
        let point = TestPoint { x: 42, y: 123 };
        let mut buf = vec![0u8; 4]; // Too small

        let result = point.encode_cdr2_le(&mut buf);
        assert_eq!(result, Err(CdrError::BufferTooSmall));
    }

    #[test]
    fn test_unexpected_eof() {
        let buf = vec![0u8; 4]; // Too small for decode

        let result = TestPoint::decode_cdr2_le(&buf);
        assert_eq!(result, Err(CdrError::UnexpectedEof));
    }

    // DDS trait test removed - DDS is defined in api::DDS, not here

    #[test]
    fn test_cdr_error_display() {
        assert_eq!(
            CdrError::BufferTooSmall.to_string(),
            "Buffer too small for CDR2 encoding"
        );
        assert_eq!(
            CdrError::UnexpectedEof.to_string(),
            "Unexpected end of buffer during CDR2 decoding"
        );
        assert_eq!(
            CdrError::InvalidEncoding.to_string(),
            "Invalid UTF-8 encoding in string field"
        );
    }

    #[test]
    fn test_cdr_error_to_crate_error() {
        let cdr_err = CdrError::BufferTooSmall;
        let _crate_err: crate::Error = cdr_err.into();
        // Should compile and convert successfully
    }

    #[test]
    fn test_string_encode_decode_roundtrip() {
        let original = "Hello, CDR2!".to_string();
        let mut buf = vec![0u8; 256];

        // Encode
        let encoded_len = original
            .encode_cdr2_le(&mut buf)
            .expect("Encode should succeed");
        // 4 (length) + 12 (chars) + 1 (null) = 17
        assert_eq!(encoded_len, 17);

        // Verify wire format
        assert_eq!(&buf[0..4], &12u32.to_le_bytes()); // length = 12
        assert_eq!(&buf[4..16], b"Hello, CDR2!");
        assert_eq!(buf[16], 0); // null terminator

        // Decode
        let (decoded, used) =
            String::decode_cdr2_le(&buf[..encoded_len]).expect("Decode should succeed");
        assert_eq!(decoded, original);
        assert_eq!(used, 17);
    }

    #[test]
    fn test_string_empty() {
        let original = String::new();
        let mut buf = vec![0u8; 256];

        let encoded_len = original
            .encode_cdr2_le(&mut buf)
            .expect("Encode should succeed");
        assert_eq!(encoded_len, 5); // 4 (length=0) + 0 (chars) + 1 (null)

        let (decoded, used) =
            String::decode_cdr2_le(&buf[..encoded_len]).expect("Decode should succeed");
        assert_eq!(decoded, original);
        assert_eq!(used, 5);
    }

    // ================================================================
    // bool tests (GAP-001)
    // ================================================================

    #[test]
    fn test_bool_true_roundtrip() {
        let mut buf = [0u8; 1];
        let n = true.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 1);
        assert_eq!(buf[0], 1);
        let (val, n) = bool::decode_cdr2_le(&buf).unwrap();
        assert!(val);
        assert_eq!(n, 1);
    }

    #[test]
    fn test_bool_false_roundtrip() {
        let mut buf = [0u8; 1];
        let n = false.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 1);
        assert_eq!(buf[0], 0);
        let (val, n) = bool::decode_cdr2_le(&buf).unwrap();
        assert!(!val);
        assert_eq!(n, 1);
    }

    #[test]
    fn test_bool_invalid_value() {
        let buf = [2u8];
        let result = bool::decode_cdr2_le(&buf);
        assert!(result.is_err());
    }

    // ================================================================
    // char tests (GAP-005)
    // ================================================================

    #[test]
    fn test_char_roundtrip() {
        let mut buf = [0u8; 1];
        let n = 'A'.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 1);
        assert_eq!(buf[0], b'A');
        let (val, n) = char::decode_cdr2_le(&buf).unwrap();
        assert_eq!(val, 'A');
        assert_eq!(n, 1);
    }

    #[test]
    fn test_char_non_ascii_rejected() {
        let mut buf = [0u8; 4];
        let result = '\u{00E9}'.encode_cdr2_le(&mut buf); // e-acute
        assert!(result.is_err());
    }

    // ================================================================
    // [T; N] tests (GAP-002)
    // ================================================================

    #[test]
    fn test_array_u32_roundtrip() {
        let arr: [u32; 3] = [10, 20, 30];
        let mut buf = [0u8; 12];
        let n = arr.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 12); // 3 * 4 bytes, NO length prefix
        let (decoded, consumed) = <[u32; 3]>::decode_cdr2_le(&buf).unwrap();
        assert_eq!(decoded, arr);
        assert_eq!(consumed, 12);
    }

    #[test]
    fn test_array_single_element() {
        let arr: [u8; 1] = [0xFF];
        let mut buf = [0u8; 1];
        let n = arr.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 1);
        let (decoded, _) = <[u8; 1]>::decode_cdr2_le(&buf).unwrap();
        assert_eq!(decoded, [0xFF]);
    }

    // ================================================================
    // Option<T> tests (GAP-003)
    // ================================================================

    #[test]
    fn test_option_none_roundtrip() {
        let val: Option<u32> = None;
        let mut buf = [0u8; 8];
        let n = val.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 1);
        assert_eq!(buf[0], 0);
        let (decoded, consumed) = Option::<u32>::decode_cdr2_le(&buf[..n]).unwrap();
        assert_eq!(decoded, None);
        assert_eq!(consumed, 1);
    }

    #[test]
    fn test_option_some_roundtrip() {
        let val: Option<u32> = Some(42);
        let mut buf = [0u8; 8];
        let n = val.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 5); // 1 flag + 4 u32
        assert_eq!(buf[0], 1);
        let (decoded, consumed) = Option::<u32>::decode_cdr2_le(&buf[..n]).unwrap();
        assert_eq!(decoded, Some(42));
        assert_eq!(consumed, 5);
    }

    #[test]
    fn test_option_invalid_flag() {
        let buf = [2u8, 0, 0, 0, 0];
        let result = Option::<u32>::decode_cdr2_le(&buf);
        assert!(result.is_err());
    }

    // ================================================================
    // BTreeMap<K, V> tests (GAP-007)
    // ================================================================

    #[test]
    fn test_btreemap_empty_roundtrip() {
        let map: std::collections::BTreeMap<u32, u32> = std::collections::BTreeMap::new();
        let mut buf = [0u8; 64];
        let n = map.encode_cdr2_le(&mut buf).unwrap();
        assert_eq!(n, 4); // just the length prefix
        let (decoded, consumed) =
            std::collections::BTreeMap::<u32, u32>::decode_cdr2_le(&buf[..n]).unwrap();
        assert!(decoded.is_empty());
        assert_eq!(consumed, 4);
    }

    #[test]
    fn test_btreemap_populated_roundtrip() {
        let mut map = std::collections::BTreeMap::new();
        map.insert("alpha".to_string(), 1i32);
        map.insert("beta".to_string(), 2i32);
        let mut buf = [0u8; 256];
        let n = map.encode_cdr2_le(&mut buf).unwrap();
        let (decoded, consumed) =
            std::collections::BTreeMap::<String, i32>::decode_cdr2_le(&buf[..n]).unwrap();
        assert_eq!(decoded, map);
        assert_eq!(consumed, n);
    }

    #[test]
    fn test_btreemap_deterministic() {
        // BTreeMap iteration is sorted -- encoding must be deterministic
        let mut map1 = std::collections::BTreeMap::new();
        map1.insert(3u32, 30u32);
        map1.insert(1u32, 10u32);
        map1.insert(2u32, 20u32);

        let mut map2 = std::collections::BTreeMap::new();
        map2.insert(1u32, 10u32);
        map2.insert(2u32, 20u32);
        map2.insert(3u32, 30u32);

        let mut buf1 = [0u8; 64];
        let mut buf2 = [0u8; 64];
        let n1 = map1.encode_cdr2_le(&mut buf1).unwrap();
        let n2 = map2.encode_cdr2_le(&mut buf2).unwrap();
        assert_eq!(&buf1[..n1], &buf2[..n2]);
    }

    #[test]
    fn test_str_encode() {
        let original: &str = "test";
        let mut buf = vec![0u8; 256];

        let encoded_len = original
            .encode_cdr2_le(&mut buf)
            .expect("Encode should succeed");
        assert_eq!(encoded_len, 9); // 4 + 4 + 1

        // Should be decodable as String
        let (decoded, _) =
            String::decode_cdr2_le(&buf[..encoded_len]).expect("Decode should succeed");
        assert_eq!(decoded, "test");
    }
}
