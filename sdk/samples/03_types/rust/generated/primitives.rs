// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod hdds_samples {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct Primitives {
        pub bool_val: bool,
        pub octet_val: u8,
        pub char_val: char,
        pub short_val: i16,
        pub ushort_val: u16,
        pub long_val: i32,
        pub ulong_val: u32,
        pub llong_val: i64,
        pub ullong_val: u64,
        pub float_val: f32,
        pub double_val: f64,
    }
    
    impl Cdr2Encode for Primitives {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = u8::from(self.bool_val);
            offset += 1;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.octet_val;
            offset += 1;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            let scalar = u32::from(self.char_val);
            let byte = u8::try_from(scalar).map_err(|_| CdrError::InvalidEncoding)?;
            dst[offset] = byte;
            offset += 1;
    
            // Align to 2-byte boundary for field 'short_val'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if dst.len() < offset + 2 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+2].copy_from_slice(&self.short_val.to_le_bytes());
            offset += 2;
    
            // Align to 2-byte boundary for field 'ushort_val'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if dst.len() < offset + 2 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+2].copy_from_slice(&self.ushort_val.to_le_bytes());
            offset += 2;
    
            // Align to 4-byte boundary for field 'long_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.long_val.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'ulong_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.ulong_val.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'llong_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.llong_val.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'ullong_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.ullong_val.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'float_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.float_val.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'double_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.double_val.to_le_bytes());
            offset += 8;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            1 + 1 + 1 + 1 + 2 + 1 + 2 + 3 + 4 + 3 + 4 + 7 + 8 + 7 + 8 + 3 + 4 + 7 + 8
        }
    }
    
    impl Cdr2Decode for Primitives {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let bool_val = src[offset] != 0;
            offset += 1;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let octet_val = src[offset];
            offset += 1;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let char_val = char::from(src[offset]);
            offset += 1;
    
            // Align to 2-byte boundary for field 'short_val'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if src.len() < offset + 2 {
                return Err(CdrError::UnexpectedEof);
            }
            let short_val = {
                let mut __hdds_tmp = [0u8; 2];
                __hdds_tmp.copy_from_slice(&src[offset..offset+2]);
                i16::from_le_bytes(__hdds_tmp)
            };
            offset += 2;
    
            // Align to 2-byte boundary for field 'ushort_val'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if src.len() < offset + 2 {
                return Err(CdrError::UnexpectedEof);
            }
            let ushort_val = {
                let mut __hdds_tmp = [0u8; 2];
                __hdds_tmp.copy_from_slice(&src[offset..offset+2]);
                u16::from_le_bytes(__hdds_tmp)
            };
            offset += 2;
    
            // Align to 4-byte boundary for field 'long_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let long_val = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                i32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'ulong_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let ulong_val = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'llong_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let llong_val = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                i64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'ullong_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let ullong_val = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'float_val'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let float_val = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'double_val'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let double_val = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            Ok((Self {
                bool_val,
                octet_val,
                char_val,
                short_val,
                ushort_val,
                long_val,
                ulong_val,
                llong_val,
                ullong_val,
                float_val,
                double_val,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for Primitives {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x47BF4022,  // FNV-1a hash of "hdds_samples::Primitives"
                    type_name: "hdds_samples::Primitives",
                    size_bytes: 48,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "bool_val",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "octet_val",
                            offset_bytes: 1,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "char_val",
                            offset_bytes: 2,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "short_val",
                            offset_bytes: 4,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I16
                            ),
                            alignment: 2,
                            size_bytes: 2,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "ushort_val",
                            offset_bytes: 6,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U16
                            ),
                            alignment: 2,
                            size_bytes: 2,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "long_val",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "ulong_val",
                            offset_bytes: 12,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "llong_val",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "ullong_val",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "float_val",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "double_val",
                            offset_bytes: 40,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_samples::Primitives"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BOOLEAN,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("bool_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("octet_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_CHAR8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("char_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT16,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("short_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT16,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("ushort_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("long_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("ulong_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 7,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("llong_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 8,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("ullong_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 9,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("float_val"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 10,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("double_val"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Primitives {
        /// Create a builder for Primitives
        #[must_use]
        pub fn builder() -> PrimitivesBuilder {
            PrimitivesBuilder::default()
        }
    }
    
    /// Builder for `Primitives`
    #[derive(Default)]
    pub struct PrimitivesBuilder {
        bool_val: Option<bool>,
        octet_val: Option<u8>,
        char_val: Option<char>,
        short_val: Option<i16>,
        ushort_val: Option<u16>,
        long_val: Option<i32>,
        ulong_val: Option<u32>,
        llong_val: Option<i64>,
        ullong_val: Option<u64>,
        float_val: Option<f32>,
        double_val: Option<f64>,
    }
    
    impl PrimitivesBuilder {
        /// Set the `bool_val` field
        #[must_use]
        pub fn bool_val(mut self, value: bool) -> Self {
            self.bool_val = Some(value);
            self
        }
    
        /// Set the `octet_val` field
        #[must_use]
        pub fn octet_val(mut self, value: u8) -> Self {
            self.octet_val = Some(value);
            self
        }
    
        /// Set the `char_val` field
        #[must_use]
        pub fn char_val(mut self, value: char) -> Self {
            self.char_val = Some(value);
            self
        }
    
        /// Set the `short_val` field
        #[must_use]
        pub fn short_val(mut self, value: i16) -> Self {
            self.short_val = Some(value);
            self
        }
    
        /// Set the `ushort_val` field
        #[must_use]
        pub fn ushort_val(mut self, value: u16) -> Self {
            self.ushort_val = Some(value);
            self
        }
    
        /// Set the `long_val` field
        #[must_use]
        pub fn long_val(mut self, value: i32) -> Self {
            self.long_val = Some(value);
            self
        }
    
        /// Set the `ulong_val` field
        #[must_use]
        pub fn ulong_val(mut self, value: u32) -> Self {
            self.ulong_val = Some(value);
            self
        }
    
        /// Set the `llong_val` field
        #[must_use]
        pub fn llong_val(mut self, value: i64) -> Self {
            self.llong_val = Some(value);
            self
        }
    
        /// Set the `ullong_val` field
        #[must_use]
        pub fn ullong_val(mut self, value: u64) -> Self {
            self.ullong_val = Some(value);
            self
        }
    
        /// Set the `float_val` field
        #[must_use]
        pub fn float_val(mut self, value: f32) -> Self {
            self.float_val = Some(value);
            self
        }
    
        /// Set the `double_val` field
        #[must_use]
        pub fn double_val(mut self, value: f64) -> Self {
            self.double_val = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Primitives, &'static str> {
            Ok(Primitives {
                bool_val: self.bool_val.ok_or("bool_val is required")?,
                octet_val: self.octet_val.ok_or("octet_val is required")?,
                char_val: self.char_val.ok_or("char_val is required")?,
                short_val: self.short_val.ok_or("short_val is required")?,
                ushort_val: self.ushort_val.ok_or("ushort_val is required")?,
                long_val: self.long_val.ok_or("long_val is required")?,
                ulong_val: self.ulong_val.ok_or("ulong_val is required")?,
                llong_val: self.llong_val.ok_or("llong_val is required")?,
                ullong_val: self.ullong_val.ok_or("ullong_val is required")?,
                float_val: self.float_val.ok_or("float_val is required")?,
                double_val: self.double_val.ok_or("double_val is required")?,
            })
        }
    }
    
    }

