// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod hdds_interop {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct StringMsg {
        pub data: String,
    }
    
    impl Cdr2Encode for StringMsg {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'data'
            let bytes = self.data.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + (4 + 256 + 1)
        }
    }
    
    impl Cdr2Decode for StringMsg {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'data'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let data = s.to_string();
            offset += len + 1; // skip null terminator
    
            Ok((Self {
                data,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for StringMsg {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x57F585D0,  // FNV-1a hash of "hdds_interop::StringMsg"
                    type_name: "hdds_interop::StringMsg",
                    size_bytes: 24,
                    alignment: 8,
                    is_variable_size: true,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "data",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_interop::StringMsg"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("data"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl StringMsg {
        /// Create a builder for StringMsg
        #[must_use]
        pub fn builder() -> StringMsgBuilder {
            StringMsgBuilder::default()
        }
    }
    
    /// Builder for `StringMsg`
    #[derive(Default)]
    pub struct StringMsgBuilder {
        data: Option<String>,
    }
    
    impl StringMsgBuilder {
        /// Set the `data` field
        #[must_use]
        pub fn data(mut self, value: impl Into<String>) -> Self {
            self.data = Some(value.into());
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<StringMsg, &'static str> {
            Ok(StringMsg {
                data: self.data.ok_or("data is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct TimestampedData {
        pub timestamp_ns: u64,
        pub sender_id: u32,
        pub sequence_num: u32,
        pub payload: Vec<u8>,  // was: sequence<octet> payload
    }
    
    impl Cdr2Encode for TimestampedData {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'timestamp_ns'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp_ns.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'sender_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.sender_id.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'sequence_num'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.sequence_num.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'payload'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode sequence field 'payload'
            let count_u32 = u32::try_from(self.payload.len()).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&count_u32.to_le_bytes());
            offset += 4;
            for elem in &self.payload {
                if dst.len() < offset + 1 {
                    return Err(CdrError::BufferTooSmall);
                }
                dst[offset..offset+1].copy_from_slice(&elem.to_le_bytes());
                offset += 1;
            }
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            7 + 8 + 3 + 4 + 3 + 4 + 3 + (4 + 1024)
        }
    }
    
    impl Cdr2Decode for TimestampedData {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'timestamp_ns'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp_ns = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'sender_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let sender_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'sequence_num'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let sequence_num = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'payload'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode sequence field 'payload'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let count = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            let mut payload = Vec::with_capacity(count);
            for _ in 0..count {
                if src.len() < offset + 1 {
                    return Err(CdrError::UnexpectedEof);
                }
                let elem = {
                    let mut __hdds_tmp = [0u8; 1];
                    __hdds_tmp.copy_from_slice(&src[offset..offset+1]);
                    u8::from_le_bytes(__hdds_tmp)
                };
                payload.push(elem);
                offset += 1;
            }
    
            Ok((Self {
                timestamp_ns,
                sender_id,
                sequence_num,
                payload,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for TimestampedData {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xB0033D67,  // FNV-1a hash of "hdds_interop::TimestampedData"
                    type_name: "hdds_interop::TimestampedData",
                    size_bytes: 40,
                    alignment: 8,
                    is_variable_size: true,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp_ns",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "sender_id",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "sequence_num",
                            offset_bytes: 12,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "payload",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_interop::TimestampedData"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp_ns"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("sender_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("sequence_num"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("payload"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl TimestampedData {
        /// Create a builder for TimestampedData
        #[must_use]
        pub fn builder() -> TimestampedDataBuilder {
            TimestampedDataBuilder::default()
        }
    }
    
    /// Builder for `TimestampedData`
    #[derive(Default)]
    pub struct TimestampedDataBuilder {
        timestamp_ns: Option<u64>,
        sender_id: Option<u32>,
        sequence_num: Option<u32>,
        payload: Option<Vec<u8>>,
    }
    
    impl TimestampedDataBuilder {
        /// Set the `timestamp_ns` field
        #[must_use]
        pub fn timestamp_ns(mut self, value: u64) -> Self {
            self.timestamp_ns = Some(value);
            self
        }
    
        /// Set the `sender_id` field
        #[must_use]
        pub fn sender_id(mut self, value: u32) -> Self {
            self.sender_id = Some(value);
            self
        }
    
        /// Set the `sequence_num` field
        #[must_use]
        pub fn sequence_num(mut self, value: u32) -> Self {
            self.sequence_num = Some(value);
            self
        }
    
        /// Set the `payload` field
        #[must_use]
        pub fn payload(mut self, value: Vec<u8>) -> Self {
            self.payload = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<TimestampedData, &'static str> {
            Ok(TimestampedData {
                timestamp_ns: self.timestamp_ns.ok_or("timestamp_ns is required")?,
                sender_id: self.sender_id.ok_or("sender_id is required")?,
                sequence_num: self.sequence_num.ok_or("sequence_num is required")?,
                payload: self.payload.ok_or("payload is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct DiscoveryInfo {
        pub vendor_name: String,
        pub version: String,
        pub domain_id: u32,
        pub participant_name: String,
    }
    
    impl Cdr2Encode for DiscoveryInfo {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'vendor_name'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'vendor_name'
            let bytes = self.vendor_name.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            // Align to 4-byte boundary for field 'version'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'version'
            let bytes = self.version.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            // Align to 4-byte boundary for field 'domain_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.domain_id.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'participant_name'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'participant_name'
            let bytes = self.participant_name.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + (4 + 256 + 1) + 3 + (4 + 256 + 1) + 3 + 4 + 3 + (4 + 256 + 1)
        }
    }
    
    impl Cdr2Decode for DiscoveryInfo {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'vendor_name'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'vendor_name'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let vendor_name = s.to_string();
            offset += len + 1; // skip null terminator
    
            // Align to 4-byte boundary for field 'version'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'version'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let version = s.to_string();
            offset += len + 1; // skip null terminator
    
            // Align to 4-byte boundary for field 'domain_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let domain_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'participant_name'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'participant_name'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let participant_name = s.to_string();
            offset += len + 1; // skip null terminator
    
            Ok((Self {
                vendor_name,
                version,
                domain_id,
                participant_name,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for DiscoveryInfo {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x16C3A7AC,  // FNV-1a hash of "hdds_interop::DiscoveryInfo"
                    type_name: "hdds_interop::DiscoveryInfo",
                    size_bytes: 80,
                    alignment: 8,
                    is_variable_size: true,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "vendor_name",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "version",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "domain_id",
                            offset_bytes: 48,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "participant_name",
                            offset_bytes: 56,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_interop::DiscoveryInfo"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("vendor_name"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("version"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("domain_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("participant_name"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl DiscoveryInfo {
        /// Create a builder for DiscoveryInfo
        #[must_use]
        pub fn builder() -> DiscoveryInfoBuilder {
            DiscoveryInfoBuilder::default()
        }
    }
    
    /// Builder for `DiscoveryInfo`
    #[derive(Default)]
    pub struct DiscoveryInfoBuilder {
        vendor_name: Option<String>,
        version: Option<String>,
        domain_id: Option<u32>,
        participant_name: Option<String>,
    }
    
    impl DiscoveryInfoBuilder {
        /// Set the `vendor_name` field
        #[must_use]
        pub fn vendor_name(mut self, value: impl Into<String>) -> Self {
            self.vendor_name = Some(value.into());
            self
        }
    
        /// Set the `version` field
        #[must_use]
        pub fn version(mut self, value: impl Into<String>) -> Self {
            self.version = Some(value.into());
            self
        }
    
        /// Set the `domain_id` field
        #[must_use]
        pub fn domain_id(mut self, value: u32) -> Self {
            self.domain_id = Some(value);
            self
        }
    
        /// Set the `participant_name` field
        #[must_use]
        pub fn participant_name(mut self, value: impl Into<String>) -> Self {
            self.participant_name = Some(value.into());
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<DiscoveryInfo, &'static str> {
            Ok(DiscoveryInfo {
                vendor_name: self.vendor_name.ok_or("vendor_name is required")?,
                version: self.version.ok_or("version is required")?,
                domain_id: self.domain_id.ok_or("domain_id is required")?,
                participant_name: self.participant_name.ok_or("participant_name is required")?,
            })
        }
    }
    
    }

