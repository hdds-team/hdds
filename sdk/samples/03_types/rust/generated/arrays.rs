// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod hdds_samples {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct Arrays {
        pub numbers: Vec<i32>,  // was: sequence<long, 10> numbers
        pub names: Vec<String>,  // was: sequence<string, 5> names
        pub transform: Vec<Vec<f32>>,  // was: sequence<sequence<float, 3>, 3> transform
    }
    
    impl Cdr2Encode for Arrays {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'numbers'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode sequence field 'numbers'
            let count_u32 = u32::try_from(self.numbers.len()).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&count_u32.to_le_bytes());
            offset += 4;
            for elem in &self.numbers {
                if dst.len() < offset + 4 {
                    return Err(CdrError::BufferTooSmall);
                }
                dst[offset..offset+4].copy_from_slice(&elem.to_le_bytes());
                offset += 4;
            }
    
            // Align to 4-byte boundary for field 'names'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode sequence field 'names'
            let count_u32 = u32::try_from(self.names.len()).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&count_u32.to_le_bytes());
            offset += 4;
            for elem in &self.names {
                let bytes = elem.as_bytes();
                let len = bytes.len();
                let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
                if dst.len() < offset + 4 + len + 1 {
                    return Err(CdrError::BufferTooSmall);
                }
                dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
                offset += 4;
                dst[offset..offset+len].copy_from_slice(bytes);
                offset += len;
                dst[offset] = 0; // null terminator
                offset += 1;
    
            }
    
            // Align to 4-byte boundary for field 'transform'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode sequence field 'transform'
            let count_u32 = u32::try_from(self.transform.len()).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&count_u32.to_le_bytes());
            offset += 4;
            for elem in &self.transform {
                let used = elem.encode_cdr2_le(&mut dst[offset..])?;
                offset += used;
            }
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + (4 + 1024) + 3 + (4 + 1024) + 3 + (4 + 1024)
        }
    }
    
    impl Cdr2Decode for Arrays {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'numbers'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode sequence field 'numbers'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let count = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            let mut numbers = Vec::with_capacity(count);
            for _ in 0..count {
                if src.len() < offset + 4 {
                    return Err(CdrError::UnexpectedEof);
                }
                let elem = {
                    let mut __hdds_tmp = [0u8; 4];
                    __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                    i32::from_le_bytes(__hdds_tmp)
                };
                numbers.push(elem);
                offset += 4;
            }
    
            // Align to 4-byte boundary for field 'names'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode sequence field 'names'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let count = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            let mut names = Vec::with_capacity(count);
            for _ in 0..count {
                if src.len() < offset + 4 {
                    return Err(CdrError::UnexpectedEof);
                }
                let len = {
                    let mut __hdds_tmp = [0u8; 4];
                    __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                    u32::from_le_bytes(__hdds_tmp) as usize
                };
                offset += 4;
                if src.len() < offset + len + 1 {
                    return Err(CdrError::UnexpectedEof);
                }
                let bytes = &src[offset..offset+len];
                let value = String::from_utf8(bytes.to_vec()).map_err(|_| CdrError::InvalidEncoding)?;
                offset += len;
                offset += 1; // skip null terminator
                names.push(value);
            }
    
            // Align to 4-byte boundary for field 'transform'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode sequence field 'transform'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let count = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            let mut transform = Vec::with_capacity(count);
            for _ in 0..count {
                let (elem, used) = <Vec<f32>>::decode_cdr2_le(&src[offset..])?;
                offset += used;
                transform.push(elem);
            }
    
            Ok((Self {
                numbers,
                names,
                transform,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for Arrays {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x3BAE0426,  // FNV-1a hash of "hdds_samples::Arrays"
                    type_name: "hdds_samples::Arrays",
                    size_bytes: 72,
                    alignment: 8,
                    is_variable_size: true,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "numbers",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "names",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "transform",
                            offset_bytes: 48,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 24,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_samples::Arrays"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("numbers"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("names"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("transform"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Arrays {
        /// Create a builder for Arrays
        #[must_use]
        pub fn builder() -> ArraysBuilder {
            ArraysBuilder::default()
        }
    }
    
    /// Builder for `Arrays`
    #[derive(Default)]
    pub struct ArraysBuilder {
        numbers: Option<Vec<i32>>,
        names: Option<Vec<String>>,
        transform: Option<Vec<Vec<f32>>>,
    }
    
    impl ArraysBuilder {
        /// Set the `numbers` field
        #[must_use]
        pub fn numbers(mut self, value: Vec<i32>) -> Self {
            self.numbers = Some(value);
            self
        }
    
        /// Set the `names` field
        #[must_use]
        pub fn names(mut self, value: Vec<String>) -> Self {
            self.names = Some(value);
            self
        }
    
        /// Set the `transform` field
        #[must_use]
        pub fn transform(mut self, value: Vec<Vec<f32>>) -> Self {
            self.transform = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Arrays, &'static str> {
            Ok(Arrays {
                numbers: self.numbers.ok_or("numbers is required")?,
                names: self.names.ok_or("names is required")?,
                transform: self.transform.ok_or("transform is required")?,
            })
        }
    }
    
    }

