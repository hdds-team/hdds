// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod hdds_samples {
    use super::*;

    pub type Permissions = u64;
    pub const PERMISSIONS_READ: Permissions = 1u64 << 0;
    pub const PERMISSIONS_WRITE: Permissions = 1u64 << 1;
    pub const PERMISSIONS_EXECUTE: Permissions = 1u64 << 2;
    pub const PERMISSIONS_DELETE: Permissions = 1u64 << 3;
    
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct StatusFlags { pub bits: u64 }
    impl StatusFlags {
        /// Field priority: width 4 at bit 0
        pub const PRIORITY_SHIFT: u32 = 0;
        pub const PRIORITY_MASK: u64 = ((1u64 << 4) - 1) << Self::PRIORITY_SHIFT;
        #[inline]
        pub fn priority(&self) -> u64 {
            (self.bits & Self::PRIORITY_MASK) >> Self::PRIORITY_SHIFT
        }
        #[inline]
        pub fn set_priority(&mut self, value: u64) {
            let v = (value & ((1u64 << 4) - 1)) << Self::PRIORITY_SHIFT;
            self.bits = (self.bits & !Self::PRIORITY_MASK) | v;
        }
        #[inline]
        pub fn with_priority(mut self, value: u64) -> Self {
            self.set_priority(value);
            self
        }
        /// Field active: width 1 at bit 4
        pub const ACTIVE_SHIFT: u32 = 4;
        pub const ACTIVE_MASK: u64 = ((1u64 << 1) - 1) << Self::ACTIVE_SHIFT;
        #[inline]
        pub fn active(&self) -> u64 {
            (self.bits & Self::ACTIVE_MASK) >> Self::ACTIVE_SHIFT
        }
        #[inline]
        pub fn set_active(&mut self, value: u64) {
            let v = (value & ((1u64 << 1) - 1)) << Self::ACTIVE_SHIFT;
            self.bits = (self.bits & !Self::ACTIVE_MASK) | v;
        }
        #[inline]
        pub fn with_active(mut self, value: u64) -> Self {
            self.set_active(value);
            self
        }
        /// Field error: width 1 at bit 5
        pub const ERROR_SHIFT: u32 = 5;
        pub const ERROR_MASK: u64 = ((1u64 << 1) - 1) << Self::ERROR_SHIFT;
        #[inline]
        pub fn error(&self) -> u64 {
            (self.bits & Self::ERROR_MASK) >> Self::ERROR_SHIFT
        }
        #[inline]
        pub fn set_error(&mut self, value: u64) {
            let v = (value & ((1u64 << 1) - 1)) << Self::ERROR_SHIFT;
            self.bits = (self.bits & !Self::ERROR_MASK) | v;
        }
        #[inline]
        pub fn with_error(mut self, value: u64) -> Self {
            self.set_error(value);
            self
        }
        /// Field warning: width 1 at bit 6
        pub const WARNING_SHIFT: u32 = 6;
        pub const WARNING_MASK: u64 = ((1u64 << 1) - 1) << Self::WARNING_SHIFT;
        #[inline]
        pub fn warning(&self) -> u64 {
            (self.bits & Self::WARNING_MASK) >> Self::WARNING_SHIFT
        }
        #[inline]
        pub fn set_warning(&mut self, value: u64) {
            let v = (value & ((1u64 << 1) - 1)) << Self::WARNING_SHIFT;
            self.bits = (self.bits & !Self::WARNING_MASK) | v;
        }
        #[inline]
        pub fn with_warning(mut self, value: u64) -> Self {
            self.set_warning(value);
            self
        }
        #[inline]
        pub const fn zero() -> Self { Self { bits: 0 } }
        #[inline]
        pub const fn from_bits(bits: u64) -> Self { Self { bits } }
        #[inline]
        pub const fn bits(&self) -> u64 { self.bits }
    }
    
    
    impl Default for StatusFlags {
        fn default() -> Self { Self::zero() }
    }
    
    impl Cdr2Encode for StatusFlags {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            if dst.len() < 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[..8].copy_from_slice(&self.bits.to_le_bytes());
            Ok(8)
        }
        fn max_cdr2_size(&self) -> usize { 8 }
    }
    
    impl Cdr2Decode for StatusFlags {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            if src.len() < 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let mut bytes = [0u8; 8];
            bytes.copy_from_slice(&src[..8]);
            Ok((Self { bits: u64::from_le_bytes(bytes) }, 8))
        }
    }
        #[derive(Debug, Clone, PartialEq)]
    pub struct Bits {
        pub perms: Permissions,
        pub flags: StatusFlags,
    }
    
    impl Cdr2Encode for Bits {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'perms'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'perms' of type 'Permissions'
            let used = self.perms.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            // Align to 4-byte boundary for field 'flags'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'flags' of type 'StatusFlags'
            let used = self.flags.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 64 + 3 + 64
        }
    }
    
    impl Cdr2Decode for Bits {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'perms'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'perms' of type 'Permissions'
            let (perms, __used) = <Permissions>::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            // Align to 4-byte boundary for field 'flags'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'flags' of type 'StatusFlags'
            let (flags, __used) = <StatusFlags>::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            Ok((Self {
                perms,
                flags,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for Bits {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xB91A0B7C,  // FNV-1a hash of "hdds_samples::Bits"
                    type_name: "hdds_samples::Bits",
                    size_bytes: 8,
                    alignment: 4,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "perms",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "flags",
                            offset_bytes: 4,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_samples::Bits"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("perms"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("flags"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Bits {
        /// Create a builder for Bits
        #[must_use]
        pub fn builder() -> BitsBuilder {
            BitsBuilder::default()
        }
    }
    
    /// Builder for `Bits`
    #[derive(Default)]
    pub struct BitsBuilder {
        perms: Option<Permissions>,
        flags: Option<StatusFlags>,
    }
    
    impl BitsBuilder {
        /// Set the `perms` field
        #[must_use]
        pub fn perms(mut self, value: Permissions) -> Self {
            self.perms = Some(value);
            self
        }
    
        /// Set the `flags` field
        #[must_use]
        pub fn flags(mut self, value: StatusFlags) -> Self {
            self.flags = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Bits, &'static str> {
            Ok(Bits {
                perms: self.perms.ok_or("perms is required")?,
                flags: self.flags.ok_or("flags is required")?,
            })
        }
    }
    
    }

