// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod hdds_samples {
    use super::*;

    #[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
    #[repr(u32)]
    pub enum DataKind {
        #[default]
        Integer = 0,
        Float = 1,
        String = 2,
    }
    
    impl Cdr2Encode for DataKind {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            if dst.len() < 4 { return Err(CdrError::BufferTooSmall); }
            dst[..4].copy_from_slice(&(*self as u32).to_le_bytes());
            Ok(4)
        }
        fn max_cdr2_size(&self) -> usize { 4 }
    }
    
    impl Cdr2Decode for DataKind {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            if src.len() < 4 { return Err(CdrError::UnexpectedEof); }
            let v = u32::from_le_bytes([src[0], src[1], src[2], src[3]]);
            match v {
                0 => Ok((Self::Integer, 4)),
                1 => Ok((Self::Float, 4)),
                2 => Ok((Self::String, 4)),
                _ => Err(CdrError::InvalidEncoding),
            }
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub enum DataValue {
        IntVal(i32),
        FloatVal(f64),
        StrVal(String),
    }
    
    impl Cdr2Encode for DataValue {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align for discriminator
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            match self {
                Self::IntVal(v) => {
                    // Encode discriminator
                    if dst.len() < offset + 4 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+4].copy_from_slice(&(DataKind::Integer as u32 as i32).to_le_bytes());
                    offset += 4;
    
                    // Align for value
                    let padding = (4 - (offset % 4)) % 4;
                    offset += padding;
    
    if dst.len() < offset + 4 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+4].copy_from_slice(&v.to_le_bytes());
                    offset += 4;
                }
                Self::FloatVal(v) => {
                    // Encode discriminator
                    if dst.len() < offset + 4 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+4].copy_from_slice(&(DataKind::Float as u32 as i32).to_le_bytes());
                    offset += 4;
    
                    // Align for value
                    let padding = (8 - (offset % 8)) % 8;
                    offset += padding;
    
    if dst.len() < offset + 8 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+8].copy_from_slice(&v.to_le_bytes());
                    offset += 8;
                }
                Self::StrVal(v) => {
                    // Encode discriminator
                    if dst.len() < offset + 4 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+4].copy_from_slice(&(DataKind::String as u32 as i32).to_le_bytes());
                    offset += 4;
    
                    // Align for value
                    let padding = (4 - (offset % 4)) % 4;
                    offset += padding;
    
    let bytes = v.as_bytes();
                    let len = bytes.len();
                    let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
                    if dst.len() < offset + 4 + len + 1 { return Err(CdrError::BufferTooSmall); }
                    dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
                    offset += 4;
                    dst[offset..offset+len].copy_from_slice(bytes);
                    offset += len;
                    dst[offset] = 0;
                    offset += 1;
                }
            }
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Discriminator + max variant size (conservative)
            8 + 261
        }
    }
    
    impl Cdr2Decode for DataValue {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align for discriminator
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode discriminator
            if src.len() < offset + 4 { return Err(CdrError::UnexpectedEof); }
            let disc = i32::from_le_bytes(src[offset..offset+4].try_into().unwrap());
            offset += 4;
    
            match disc {
                d if d == DataKind::Integer as i32 => {
                    // Align for value
                    let padding = (4 - (offset % 4)) % 4;
                    offset += padding;
    
                    let val = { if src.len() < offset + 4 { return Err(CdrError::UnexpectedEof); } let v = i32::from_le_bytes(src[offset..offset+4].try_into().unwrap()); offset += 4; v };
                    Ok((Self::IntVal(val), offset))
                }
                d if d == DataKind::Float as i32 => {
                    // Align for value
                    let padding = (8 - (offset % 8)) % 8;
                    offset += padding;
    
                    let val = { if src.len() < offset + 8 { return Err(CdrError::UnexpectedEof); } let v = f64::from_le_bytes(src[offset..offset+8].try_into().unwrap()); offset += 8; v };
                    Ok((Self::FloatVal(val), offset))
                }
                d if d == DataKind::String as i32 => {
                    // Align for value
                    let padding = (4 - (offset % 4)) % 4;
                    offset += padding;
    
                    let val = { if src.len() < offset + 4 { return Err(CdrError::UnexpectedEof); } let len = u32::from_le_bytes(src[offset..offset+4].try_into().unwrap()) as usize; offset += 4; if src.len() < offset + len { return Err(CdrError::UnexpectedEof); } let s = String::from_utf8_lossy(&src[offset..offset+len-1]).to_string(); offset += len; s };
                    Ok((Self::StrVal(val), offset))
                }
                _ => Err(CdrError::InvalidEncoding),
            }
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Unions {
        pub kind: DataKind,
        pub value: DataValue,
    }
    
    impl Cdr2Encode for Unions {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'kind'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'kind' of type 'DataKind'
            let used = self.kind.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'value' of type 'DataValue'
            let used = self.value.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 64 + 3 + 64
        }
    }
    
    impl Cdr2Decode for Unions {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'kind'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'kind' of type 'DataKind'
            let (kind, __used) = <DataKind>::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'value' of type 'DataValue'
            let (value, __used) = <DataValue>::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            Ok((Self {
                kind,
                value,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by hddsgen) ===
        impl ::hdds::api::DDS for Unions {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x325B85D8,  // FNV-1a hash of "hdds_samples::Unions"
                    type_name: "hdds_samples::Unions",
                    size_bytes: 8,
                    alignment: 4,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "kind",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "value",
                            offset_bytes: 4,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("hdds_samples::Unions"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("kind"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("value"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Unions {
        /// Create a builder for Unions
        #[must_use]
        pub fn builder() -> UnionsBuilder {
            UnionsBuilder::default()
        }
    }
    
    /// Builder for `Unions`
    #[derive(Default)]
    pub struct UnionsBuilder {
        kind: Option<DataKind>,
        value: Option<DataValue>,
    }
    
    impl UnionsBuilder {
        /// Set the `kind` field
        #[must_use]
        pub fn kind(mut self, value: DataKind) -> Self {
            self.kind = Some(value);
            self
        }
    
        /// Set the `value` field
        #[must_use]
        pub fn value(mut self, value: DataValue) -> Self {
            self.value = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Unions, &'static str> {
            Ok(Unions {
                kind: self.kind.ok_or("kind is required")?,
                value: self.value.ok_or("value is required")?,
            })
        }
    }
    
    }

