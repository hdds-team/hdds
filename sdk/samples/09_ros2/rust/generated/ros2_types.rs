// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by idl_parser v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

#[allow(dead_code)]
pub mod ros2_msgs {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct StringMsg {
        pub data: String,
    }
    
    impl Cdr2Encode for StringMsg {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'data'
            let bytes = self.data.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + (4 + 256 + 1)
        }
    }
    
    impl Cdr2Decode for StringMsg {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'data'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let data = s.to_string();
            offset += len + 1; // skip null terminator
    
            Ok((Self {
                data,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for StringMsg {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x94C3D604,  // FNV-1a hash of "ros2_msgs::StringMsg"
                    type_name: "ros2_msgs::StringMsg",
                    size_bytes: 8,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "data",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::StringMsg"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("data"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl StringMsg {
        /// Create a builder for StringMsg
        #[must_use]
        pub fn builder() -> StringMsgBuilder {
            StringMsgBuilder::default()
        }
    }
    
    /// Builder for [StringMsg]
    #[derive(Default)]
    pub struct StringMsgBuilder {
        data: Option<String>,
    }
    
    impl StringMsgBuilder {
        /// Set the `data` field
        #[must_use]
        pub fn data(mut self, value: impl Into<String>) -> Self {
            self.data = Some(value.into());
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<StringMsg, &'static str> {
            Ok(StringMsg {
                data: self.data.ok_or("data is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Int32 {
        pub data: i32,
    }
    
    impl Cdr2Encode for Int32 {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.data.to_le_bytes());
            offset += 4;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4
        }
    }
    
    impl Cdr2Decode for Int32 {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'data'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let data = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                i32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            Ok((Self {
                data,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Int32 {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x65B50DE6,  // FNV-1a hash of "ros2_msgs::Int32"
                    type_name: "ros2_msgs::Int32",
                    size_bytes: 4,
                    alignment: 4,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "data",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Int32"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("data"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Int32 {
        /// Create a builder for Int32
        #[must_use]
        pub fn builder() -> Int32Builder {
            Int32Builder::default()
        }
    }
    
    /// Builder for [Int32]
    #[derive(Default)]
    pub struct Int32Builder {
        data: Option<i32>,
    }
    
    impl Int32Builder {
        /// Set the `data` field
        #[must_use]
        pub fn data(mut self, value: i32) -> Self {
            self.data = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Int32, &'static str> {
            Ok(Int32 {
                data: self.data.ok_or("data is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Float64 {
        pub data: f64,
    }
    
    impl Cdr2Encode for Float64 {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'data'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.data.to_le_bytes());
            offset += 8;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            7 + 8
        }
    }
    
    impl Cdr2Decode for Float64 {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'data'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let data = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            Ok((Self {
                data,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Float64 {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x233351AA,  // FNV-1a hash of "ros2_msgs::Float64"
                    type_name: "ros2_msgs::Float64",
                    size_bytes: 8,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "data",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Float64"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("data"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Float64 {
        /// Create a builder for Float64
        #[must_use]
        pub fn builder() -> Float64Builder {
            Float64Builder::default()
        }
    }
    
    /// Builder for [Float64]
    #[derive(Default)]
    pub struct Float64Builder {
        data: Option<f64>,
    }
    
    impl Float64Builder {
        /// Set the `data` field
        #[must_use]
        pub fn data(mut self, value: f64) -> Self {
            self.data = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Float64, &'static str> {
            Ok(Float64 {
                data: self.data.ok_or("data is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Time {
        pub sec: i32,
        pub nanosec: u32,
    }
    
    impl Cdr2Encode for Time {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sec'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.sec.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'nanosec'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.nanosec.to_le_bytes());
            offset += 4;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 3 + 4
        }
    }
    
    impl Cdr2Decode for Time {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sec'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let sec = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                i32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'nanosec'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let nanosec = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            Ok((Self {
                sec,
                nanosec,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Time {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x8CB8D03B,  // FNV-1a hash of "ros2_msgs::Time"
                    type_name: "ros2_msgs::Time",
                    size_bytes: 8,
                    alignment: 4,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "sec",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::I32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "nanosec",
                            offset_bytes: 4,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Time"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_INT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("sec"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("nanosec"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Time {
        /// Create a builder for Time
        #[must_use]
        pub fn builder() -> TimeBuilder {
            TimeBuilder::default()
        }
    }
    
    /// Builder for [Time]
    #[derive(Default)]
    pub struct TimeBuilder {
        sec: Option<i32>,
        nanosec: Option<u32>,
    }
    
    impl TimeBuilder {
        /// Set the `sec` field
        #[must_use]
        pub fn sec(mut self, value: i32) -> Self {
            self.sec = Some(value);
            self
        }
    
        /// Set the `nanosec` field
        #[must_use]
        pub fn nanosec(mut self, value: u32) -> Self {
            self.nanosec = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Time, &'static str> {
            Ok(Time {
                sec: self.sec.ok_or("sec is required")?,
                nanosec: self.nanosec.ok_or("nanosec is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Header {
        pub stamp: Time,
        pub frame_id: String,
    }
    
    impl Cdr2Encode for Header {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'stamp'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'stamp' of type 'Time'
            let used = self.stamp.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            // Align to 4-byte boundary for field 'frame_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode String field 'frame_id'
            let bytes = self.frame_id.as_bytes();
            let len = bytes.len();
            let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
            if dst.len() < offset + 4 + len + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
            offset += 4;
            dst[offset..offset+len].copy_from_slice(bytes);
            offset += len;
            dst[offset] = 0; // null terminator
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 64 + 3 + (4 + 256 + 1)
        }
    }
    
    impl Cdr2Decode for Header {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'stamp'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'stamp' of type 'Time'
            let (stamp, __used) = Time::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            // Align to 4-byte boundary for field 'frame_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode String field 'frame_id'
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let len = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp) as usize
            };
            offset += 4;
            if src.len() < offset + len + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let s = std::str::from_utf8(&src[offset..offset+len])
                .map_err(|_| CdrError::InvalidEncoding)?;
            let frame_id = s.to_string();
            offset += len + 1; // skip null terminator
    
            Ok((Self {
                stamp,
                frame_id,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Header {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xA209AB43,  // FNV-1a hash of "ros2_msgs::Header"
                    type_name: "ros2_msgs::Header",
                    size_bytes: 16,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "stamp",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "frame_id",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::String
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Header"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("stamp"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("frame_id"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Header {
        /// Create a builder for Header
        #[must_use]
        pub fn builder() -> HeaderBuilder {
            HeaderBuilder::default()
        }
    }
    
    /// Builder for [Header]
    #[derive(Default)]
    pub struct HeaderBuilder {
        stamp: Option<Time>,
        frame_id: Option<String>,
    }
    
    impl HeaderBuilder {
        /// Set the `stamp` field
        #[must_use]
        pub fn stamp(mut self, value: Time) -> Self {
            self.stamp = Some(value);
            self
        }
    
        /// Set the `frame_id` field
        #[must_use]
        pub fn frame_id(mut self, value: impl Into<String>) -> Self {
            self.frame_id = Some(value.into());
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Header, &'static str> {
            Ok(Header {
                stamp: self.stamp.ok_or("stamp is required")?,
                frame_id: self.frame_id.ok_or("frame_id is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Point {
        pub x: f64,
        pub y: f64,
        pub z: f64,
    }
    
    impl Cdr2Encode for Point {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'x'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.x.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'y'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.y.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'z'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.z.to_le_bytes());
            offset += 8;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            7 + 8 + 7 + 8 + 7 + 8
        }
    }
    
    impl Cdr2Decode for Point {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'x'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let x = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'y'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let y = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'z'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let z = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            Ok((Self {
                x,
                y,
                z,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Point {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xD348BDEC,  // FNV-1a hash of "ros2_msgs::Point"
                    type_name: "ros2_msgs::Point",
                    size_bytes: 24,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "x",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "y",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "z",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Point"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("x"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("y"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("z"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Point {
        /// Create a builder for Point
        #[must_use]
        pub fn builder() -> PointBuilder {
            PointBuilder::default()
        }
    }
    
    /// Builder for [Point]
    #[derive(Default)]
    pub struct PointBuilder {
        x: Option<f64>,
        y: Option<f64>,
        z: Option<f64>,
    }
    
    impl PointBuilder {
        /// Set the `x` field
        #[must_use]
        pub fn x(mut self, value: f64) -> Self {
            self.x = Some(value);
            self
        }
    
        /// Set the `y` field
        #[must_use]
        pub fn y(mut self, value: f64) -> Self {
            self.y = Some(value);
            self
        }
    
        /// Set the `z` field
        #[must_use]
        pub fn z(mut self, value: f64) -> Self {
            self.z = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Point, &'static str> {
            Ok(Point {
                x: self.x.ok_or("x is required")?,
                y: self.y.ok_or("y is required")?,
                z: self.z.ok_or("z is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Quaternion {
        pub x: f64,
        pub y: f64,
        pub z: f64,
        pub w: f64,
    }
    
    impl Cdr2Encode for Quaternion {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'x'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.x.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'y'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.y.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'z'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.z.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'w'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.w.to_le_bytes());
            offset += 8;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            7 + 8 + 7 + 8 + 7 + 8 + 7 + 8
        }
    }
    
    impl Cdr2Decode for Quaternion {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 8-byte boundary for field 'x'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let x = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'y'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let y = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'z'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let z = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'w'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let w = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            Ok((Self {
                x,
                y,
                z,
                w,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Quaternion {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x959632C2,  // FNV-1a hash of "ros2_msgs::Quaternion"
                    type_name: "ros2_msgs::Quaternion",
                    size_bytes: 32,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "x",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "y",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "z",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "w",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Quaternion"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("x"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("y"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("z"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("w"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Quaternion {
        /// Create a builder for Quaternion
        #[must_use]
        pub fn builder() -> QuaternionBuilder {
            QuaternionBuilder::default()
        }
    }
    
    /// Builder for [Quaternion]
    #[derive(Default)]
    pub struct QuaternionBuilder {
        x: Option<f64>,
        y: Option<f64>,
        z: Option<f64>,
        w: Option<f64>,
    }
    
    impl QuaternionBuilder {
        /// Set the `x` field
        #[must_use]
        pub fn x(mut self, value: f64) -> Self {
            self.x = Some(value);
            self
        }
    
        /// Set the `y` field
        #[must_use]
        pub fn y(mut self, value: f64) -> Self {
            self.y = Some(value);
            self
        }
    
        /// Set the `z` field
        #[must_use]
        pub fn z(mut self, value: f64) -> Self {
            self.z = Some(value);
            self
        }
    
        /// Set the `w` field
        #[must_use]
        pub fn w(mut self, value: f64) -> Self {
            self.w = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Quaternion, &'static str> {
            Ok(Quaternion {
                x: self.x.ok_or("x is required")?,
                y: self.y.ok_or("y is required")?,
                z: self.z.ok_or("z is required")?,
                w: self.w.ok_or("w is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Pose {
        pub position: Point,
        pub orientation: Quaternion,
    }
    
    impl Cdr2Encode for Pose {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'position'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'position' of type 'Point'
            let used = self.position.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            // Align to 4-byte boundary for field 'orientation'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'orientation' of type 'Quaternion'
            let used = self.orientation.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 64 + 3 + 64
        }
    }
    
    impl Cdr2Decode for Pose {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'position'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'position' of type 'Point'
            let (position, __used) = Point::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            // Align to 4-byte boundary for field 'orientation'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'orientation' of type 'Quaternion'
            let (orientation, __used) = Quaternion::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            Ok((Self {
                position,
                orientation,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Pose {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xCE5CA9EF,  // FNV-1a hash of "ros2_msgs::Pose"
                    type_name: "ros2_msgs::Pose",
                    size_bytes: 16,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "position",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "orientation",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Pose"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("position"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("orientation"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Pose {
        /// Create a builder for Pose
        #[must_use]
        pub fn builder() -> PoseBuilder {
            PoseBuilder::default()
        }
    }
    
    /// Builder for [Pose]
    #[derive(Default)]
    pub struct PoseBuilder {
        position: Option<Point>,
        orientation: Option<Quaternion>,
    }
    
    impl PoseBuilder {
        /// Set the `position` field
        #[must_use]
        pub fn position(mut self, value: Point) -> Self {
            self.position = Some(value);
            self
        }
    
        /// Set the `orientation` field
        #[must_use]
        pub fn orientation(mut self, value: Quaternion) -> Self {
            self.orientation = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Pose, &'static str> {
            Ok(Pose {
                position: self.position.ok_or("position is required")?,
                orientation: self.orientation.ok_or("orientation is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct Twist {
        pub linear: Point,
        pub angular: Point,
    }
    
    impl Cdr2Encode for Twist {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'linear'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'linear' of type 'Point'
            let used = self.linear.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            // Align to 4-byte boundary for field 'angular'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Encode named field 'angular' of type 'Point'
            let used = self.angular.encode_cdr2_le(&mut dst[offset..])?;
            offset += used;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 64 + 3 + 64
        }
    }
    
    impl Cdr2Decode for Twist {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'linear'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'linear' of type 'Point'
            let (linear, __used) = Point::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            // Align to 4-byte boundary for field 'angular'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            // Decode named field 'angular' of type 'Point'
            let (angular, __used) = Point::decode_cdr2_le(&src[offset..])?;
            offset += __used;
    
            Ok((Self {
                linear,
                angular,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for Twist {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xD8CC57FD,  // FNV-1a hash of "ros2_msgs::Twist"
                    type_name: "ros2_msgs::Twist",
                    size_bytes: 16,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "linear",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "angular",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("ros2_msgs::Twist"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("linear"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("angular"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl Twist {
        /// Create a builder for Twist
        #[must_use]
        pub fn builder() -> TwistBuilder {
            TwistBuilder::default()
        }
    }
    
    /// Builder for [Twist]
    #[derive(Default)]
    pub struct TwistBuilder {
        linear: Option<Point>,
        angular: Option<Point>,
    }
    
    impl TwistBuilder {
        /// Set the `linear` field
        #[must_use]
        pub fn linear(mut self, value: Point) -> Self {
            self.linear = Some(value);
            self
        }
    
        /// Set the `angular` field
        #[must_use]
        pub fn angular(mut self, value: Point) -> Self {
            self.angular = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<Twist, &'static str> {
            Ok(Twist {
                linear: self.linear.ok_or("linear is required")?,
                angular: self.angular.ok_or("angular is required")?,
            })
        }
    }
    
    }
