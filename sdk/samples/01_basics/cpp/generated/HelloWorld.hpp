// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v1.0.115
// DO NOT EDIT

#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdlib>
#include <string>

// CDR2 serialization helpers (with include guard to allow multiple IDL files)
#ifndef HDDS_CDR2_HELPERS_DEFINED
#define HDDS_CDR2_HELPERS_DEFINED
namespace cdr2 {

inline std::size_t align_offset(std::size_t offset, std::size_t alignment) noexcept {
    return (offset + alignment - 1) & ~(alignment - 1);
}

inline bool can_write(std::size_t len, std::size_t offset, std::size_t bytes) noexcept {
    return offset + bytes <= len;
}

inline bool can_read(std::size_t len, std::size_t offset, std::size_t bytes) noexcept {
    return offset + bytes <= len;
}

template<typename T>
inline void write_le(std::uint8_t* dst, std::size_t& offset, T value) noexcept {
    std::memcpy(dst + offset, &value, sizeof(T));
    offset += sizeof(T);
}

template<typename T>
inline T read_le(const std::uint8_t* src, std::size_t& offset) noexcept {
    T value;
    std::memcpy(&value, src + offset, sizeof(T));
    offset += sizeof(T);
    return value;
}

}  // namespace cdr2
#endif // HDDS_CDR2_HELPERS_DEFINED

namespace hdds_samples {

    struct HelloWorld {
        int32_t id = 0;
        std::string message;

        HelloWorld() = default;
        HelloWorld(int32_t id, std::string message)
            : id(std::move(id)), message(std::move(message)) {}

        /// Encode this struct to CDR2 little-endian format
        /// Returns the number of bytes written, or -1 on error
        [[nodiscard]] int encode_cdr2_le(std::uint8_t* dst, std::size_t len) const noexcept {
            std::size_t offset = 0;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_write(len, offset, 4)) return -1;
            std::memcpy(dst + offset, &(this->id), 4);
            offset += 4;
            offset = cdr2::align_offset(offset, 4);
            {
                std::uint32_t str_len = static_cast<std::uint32_t>(this->message.size() + 1);
                if (!cdr2::can_write(len, offset, 4 + str_len)) return -1;
                std::memcpy(dst + offset, &str_len, 4);
                offset += 4;
                std::memcpy(dst + offset, this->message.c_str(), str_len);
                offset += str_len;
            }
            return static_cast<int>(offset);
        }

        /// Decode this struct from CDR2 little-endian format
        /// Returns the number of bytes read, or -1 on error
        [[nodiscard]] int decode_cdr2_le(const std::uint8_t* src, std::size_t len) noexcept {
            std::size_t offset = 0;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_read(len, offset, 4)) return -1;
            std::memcpy(&(this->id), src + offset, 4);
            offset += 4;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_read(len, offset, 4)) return -1;
            {
                std::uint32_t str_len;
                std::memcpy(&str_len, src + offset, 4);
                offset += 4;
                if (str_len == 0 || !cdr2::can_read(len, offset, str_len)) return -1;
                this->message.assign(reinterpret_cast<const char*>(src + offset), str_len - 1);
                offset += str_len;
            }
            return static_cast<int>(offset);
        }
    };

// PubSubType for HelloWorld
// Generated by hddsgen

/// TypeSupport class for HelloWorld
/// Provides DDS-compatible serialization/deserialization interface
class HelloWorldPubSubType {
public:
    using type = HelloWorld;

    static constexpr const char* type_name() noexcept { return "HelloWorld"; }

    /// Serialize data to CDR2 little-endian format
    /// @param data Pointer to the HelloWorld to serialize
    /// @param buffer Output buffer
    /// @param buffer_size Size of output buffer
    /// @return Number of bytes written, or -1 on error
    static int serialize(const void* data, std::uint8_t* buffer, std::size_t buffer_size) noexcept {
        if (!data || !buffer) return -1;
        const auto* typed = static_cast<const HelloWorld*>(data);
        return typed->encode_cdr2_le(buffer, buffer_size);
    }

    /// Deserialize data from CDR2 little-endian format
    /// @param buffer Input buffer containing CDR2 data
    /// @param buffer_size Size of input buffer
    /// @param data Pointer to HelloWorld to fill
    /// @return Number of bytes read, or -1 on error
    static int deserialize(const std::uint8_t* buffer, std::size_t buffer_size, void* data) noexcept {
        if (!buffer || !data) return -1;
        auto* typed = static_cast<HelloWorld*>(data);
        return typed->decode_cdr2_le(buffer, buffer_size);
    }

    /// Calculate serialized size of data
    /// @param data Pointer to the HelloWorld
    /// @return Serialized size in bytes, or 0 on error
    static std::size_t calculate_serialized_size(const void* data) noexcept {
        if (!data) return 0;
        const auto* typed = static_cast<const HelloWorld*>(data);
        // Fast path: stack buffer for typical types
        std::uint8_t stack_buf[16384];
        int size = typed->encode_cdr2_le(stack_buf, sizeof(stack_buf));
        if (size > 0) return static_cast<std::size_t>(size);
        // Heap fallback for large types (up to 16 MB)
        for (std::size_t cap = 65536; cap <= 16777216; cap *= 4) {
            auto* p = static_cast<std::uint8_t*>(std::malloc(cap));
            if (!p) return 0;
            size = typed->encode_cdr2_le(p, cap);
            std::free(p);
            if (size > 0) return static_cast<std::size_t>(size);
        }
        return 0;
    }

    /// Create a new instance of HelloWorld
    /// @return Pointer to newly allocated HelloWorld, or nullptr on failure
    static void* create_data() noexcept {
        return new (std::nothrow) HelloWorld();
    }

    /// Delete an instance of HelloWorld
    /// @param data Pointer to HelloWorld to delete
    static void delete_data(void* data) noexcept {
        delete static_cast<HelloWorld*>(data);
    }

    /// Compute instance key (no @key fields defined)
    /// @return false (no key fields)
    static bool compute_key(const void* /*data*/, std::uint8_t key_buffer[16]) noexcept {
        std::memset(key_buffer, 0, 16);
        return false;
    }

    /// Check if this type has @key fields
    static constexpr bool has_key() noexcept { return false; }

    /// Check if type has bounded size
    static constexpr bool is_bounded() noexcept { return false; }

    /// Check if type is plain (no pointers/dynamic allocation)
    static constexpr bool is_plain() noexcept { return false; }
};

}  // namespace hdds_samples

