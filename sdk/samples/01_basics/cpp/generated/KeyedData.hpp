// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by hddsgen v1.0.115
// DO NOT EDIT

#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdlib>
#include <string>

// CDR2 serialization helpers (with include guard to allow multiple IDL files)
#ifndef HDDS_CDR2_HELPERS_DEFINED
#define HDDS_CDR2_HELPERS_DEFINED
namespace cdr2 {

inline std::size_t align_offset(std::size_t offset, std::size_t alignment) noexcept {
    return (offset + alignment - 1) & ~(alignment - 1);
}

inline bool can_write(std::size_t len, std::size_t offset, std::size_t bytes) noexcept {
    return offset + bytes <= len;
}

inline bool can_read(std::size_t len, std::size_t offset, std::size_t bytes) noexcept {
    return offset + bytes <= len;
}

template<typename T>
inline void write_le(std::uint8_t* dst, std::size_t& offset, T value) noexcept {
    std::memcpy(dst + offset, &value, sizeof(T));
    offset += sizeof(T);
}

template<typename T>
inline T read_le(const std::uint8_t* src, std::size_t& offset) noexcept {
    T value;
    std::memcpy(&value, src + offset, sizeof(T));
    offset += sizeof(T);
    return value;
}

}  // namespace cdr2
#endif // HDDS_CDR2_HELPERS_DEFINED

namespace hdds_samples {

    struct KeyedData {
        int32_t id = 0;
        std::string data;
        uint32_t sequence_num = 0;

        KeyedData() = default;
        KeyedData(int32_t id, std::string data, uint32_t sequence_num)
            : id(std::move(id)), data(std::move(data)), sequence_num(std::move(sequence_num)) {}

        /// Encode this struct to CDR2 little-endian format
        /// Returns the number of bytes written, or -1 on error
        [[nodiscard]] int encode_cdr2_le(std::uint8_t* dst, std::size_t len) const noexcept {
            std::size_t offset = 0;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_write(len, offset, 4)) return -1;
            std::memcpy(dst + offset, &(this->id), 4);
            offset += 4;
            offset = cdr2::align_offset(offset, 4);
            {
                std::uint32_t str_len = static_cast<std::uint32_t>(this->data.size() + 1);
                if (!cdr2::can_write(len, offset, 4 + str_len)) return -1;
                std::memcpy(dst + offset, &str_len, 4);
                offset += 4;
                std::memcpy(dst + offset, this->data.c_str(), str_len);
                offset += str_len;
            }
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_write(len, offset, 4)) return -1;
            std::memcpy(dst + offset, &(this->sequence_num), 4);
            offset += 4;
            return static_cast<int>(offset);
        }

        /// Decode this struct from CDR2 little-endian format
        /// Returns the number of bytes read, or -1 on error
        [[nodiscard]] int decode_cdr2_le(const std::uint8_t* src, std::size_t len) noexcept {
            std::size_t offset = 0;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_read(len, offset, 4)) return -1;
            std::memcpy(&(this->id), src + offset, 4);
            offset += 4;
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_read(len, offset, 4)) return -1;
            {
                std::uint32_t str_len;
                std::memcpy(&str_len, src + offset, 4);
                offset += 4;
                if (str_len == 0 || !cdr2::can_read(len, offset, str_len)) return -1;
                this->data.assign(reinterpret_cast<const char*>(src + offset), str_len - 1);
                offset += str_len;
            }
            offset = cdr2::align_offset(offset, 4);
            if (!cdr2::can_read(len, offset, 4)) return -1;
            std::memcpy(&(this->sequence_num), src + offset, 4);
            offset += 4;
            return static_cast<int>(offset);
        }
    };

// PubSubType for KeyedData
// Generated by hddsgen

/// TypeSupport class for KeyedData
/// Provides DDS-compatible serialization/deserialization interface
class KeyedDataPubSubType {
public:
    using type = KeyedData;

    static constexpr const char* type_name() noexcept { return "KeyedData"; }

    /// Serialize data to CDR2 little-endian format
    /// @param data Pointer to the KeyedData to serialize
    /// @param buffer Output buffer
    /// @param buffer_size Size of output buffer
    /// @return Number of bytes written, or -1 on error
    static int serialize(const void* data, std::uint8_t* buffer, std::size_t buffer_size) noexcept {
        if (!data || !buffer) return -1;
        const auto* typed = static_cast<const KeyedData*>(data);
        return typed->encode_cdr2_le(buffer, buffer_size);
    }

    /// Deserialize data from CDR2 little-endian format
    /// @param buffer Input buffer containing CDR2 data
    /// @param buffer_size Size of input buffer
    /// @param data Pointer to KeyedData to fill
    /// @return Number of bytes read, or -1 on error
    static int deserialize(const std::uint8_t* buffer, std::size_t buffer_size, void* data) noexcept {
        if (!buffer || !data) return -1;
        auto* typed = static_cast<KeyedData*>(data);
        return typed->decode_cdr2_le(buffer, buffer_size);
    }

    /// Calculate serialized size of data
    /// @param data Pointer to the KeyedData
    /// @return Serialized size in bytes, or 0 on error
    static std::size_t calculate_serialized_size(const void* data) noexcept {
        if (!data) return 0;
        const auto* typed = static_cast<const KeyedData*>(data);
        // Fast path: stack buffer for typical types
        std::uint8_t stack_buf[16384];
        int size = typed->encode_cdr2_le(stack_buf, sizeof(stack_buf));
        if (size > 0) return static_cast<std::size_t>(size);
        // Heap fallback for large types (up to 16 MB)
        for (std::size_t cap = 65536; cap <= 16777216; cap *= 4) {
            auto* p = static_cast<std::uint8_t*>(std::malloc(cap));
            if (!p) return 0;
            size = typed->encode_cdr2_le(p, cap);
            std::free(p);
            if (size > 0) return static_cast<std::size_t>(size);
        }
        return 0;
    }

    /// Create a new instance of KeyedData
    /// @return Pointer to newly allocated KeyedData, or nullptr on failure
    static void* create_data() noexcept {
        return new (std::nothrow) KeyedData();
    }

    /// Delete an instance of KeyedData
    /// @param data Pointer to KeyedData to delete
    static void delete_data(void* data) noexcept {
        delete static_cast<KeyedData*>(data);
    }

    /// Compute instance key from @key fields
    /// @param data Pointer to KeyedData
    /// @param key_buffer Output buffer for key (16 bytes)
    /// @return true if key computed, false otherwise
    static bool compute_key(const void* data, std::uint8_t key_buffer[16]) noexcept {
        if (!data || !key_buffer) return false;
        const auto* typed = static_cast<const KeyedData*>(data);
        // FNV-1a hash of key fields, expanded to 16 bytes
        std::uint64_t hash = 14695981039346656037ULL;
        {
            const auto& val = typed->id;
            const auto* ptr = reinterpret_cast<const std::uint8_t*>(&val);
            for (std::size_t i = 0; i < sizeof(val); ++i) {
                hash ^= ptr[i];
                hash *= 1099511628211ULL;
            }
        }
        // Expand hash to 16 bytes
        std::memset(key_buffer, 0, 16);
        std::memcpy(key_buffer, &hash, sizeof(hash));
        hash *= 1099511628211ULL;
        std::memcpy(key_buffer + 8, &hash, sizeof(hash));
        return true;
    }

    /// Check if this type has @key fields
    static constexpr bool has_key() noexcept { return true; }

    /// Check if type has bounded size
    static constexpr bool is_bounded() noexcept { return false; }

    /// Check if type is plain (no pointers/dynamic allocation)
    static constexpr bool is_plain() noexcept { return false; }
};

}  // namespace hdds_samples

