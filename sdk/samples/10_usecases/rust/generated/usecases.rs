// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by idl_parser v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

pub mod robotics {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct RobotState {
        pub robot_id: u32,
        pub timestamp_ns: u64,
        pub position_x: f32,
        pub position_y: f32,
        pub position_z: f32,
        pub orientation_w: f32,
        pub orientation_x: f32,
        pub orientation_y: f32,
        pub orientation_z: f32,
        pub battery_percent: f32,
        pub status: u8,
    }
    
    impl Cdr2Encode for RobotState {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'robot_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.robot_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ns'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp_ns.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'position_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.position_x.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'position_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.position_y.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'position_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.position_z.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_w'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.orientation_w.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.orientation_x.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.orientation_y.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.orientation_z.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'battery_percent'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.battery_percent.to_le_bytes());
            offset += 4;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.status;
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 1
        }
    }
    
    impl Cdr2Decode for RobotState {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'robot_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let robot_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ns'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp_ns = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'position_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let position_x = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'position_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let position_y = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'position_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let position_z = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_w'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let orientation_w = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let orientation_x = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let orientation_y = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'orientation_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let orientation_z = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'battery_percent'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let battery_percent = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let status = src[offset];
            offset += 1;
    
            Ok((Self {
                robot_id,
                timestamp_ns,
                position_x,
                position_y,
                position_z,
                orientation_w,
                orientation_x,
                orientation_y,
                orientation_z,
                battery_percent,
                status,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for RobotState {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x4683CEB9,  // FNV-1a hash of "robotics::RobotState"
                    type_name: "robotics::RobotState",
                    size_bytes: 56,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "robot_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp_ns",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "position_x",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "position_y",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "position_z",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "orientation_w",
                            offset_bytes: 28,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "orientation_x",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "orientation_y",
                            offset_bytes: 36,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "orientation_z",
                            offset_bytes: 40,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "battery_percent",
                            offset_bytes: 44,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "status",
                            offset_bytes: 48,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("robotics::RobotState"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("robot_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp_ns"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("position_x"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("position_y"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("position_z"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("orientation_w"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("orientation_x"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 7,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("orientation_y"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 8,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("orientation_z"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 9,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("battery_percent"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 10,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("status"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // FNV-1a hash of @key fields
                let mut hash: u64 = 14695981039346656037;
                const PRIME: u64 = 1099511628211;
    
                // Hash @key field: robot_id
                let bytes = self.robot_id.to_le_bytes();
                for b in bytes {
                    hash ^= b as u64;
                    hash = hash.wrapping_mul(PRIME);
                }
    
                // Expand to 16 bytes
                let mut key = [0u8; 16];
                key[..8].copy_from_slice(&hash.to_le_bytes());
                hash = hash.wrapping_mul(PRIME);
                key[8..].copy_from_slice(&hash.to_le_bytes());
                key
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { true }
        }
        
    impl RobotState {
        /// Create a builder for RobotState
        #[must_use]
        pub fn builder() -> RobotStateBuilder {
            RobotStateBuilder::default()
        }
    }
    
    /// Builder for [RobotState]
    #[derive(Default)]
    pub struct RobotStateBuilder {
        robot_id: Option<u32>,
        timestamp_ns: Option<u64>,
        position_x: Option<f32>,
        position_y: Option<f32>,
        position_z: Option<f32>,
        orientation_w: Option<f32>,
        orientation_x: Option<f32>,
        orientation_y: Option<f32>,
        orientation_z: Option<f32>,
        battery_percent: Option<f32>,
        status: Option<u8>,
    }
    
    impl RobotStateBuilder {
        /// Set the `robot_id` field
        #[must_use]
        pub fn robot_id(mut self, value: u32) -> Self {
            self.robot_id = Some(value);
            self
        }
    
        /// Set the `timestamp_ns` field
        #[must_use]
        pub fn timestamp_ns(mut self, value: u64) -> Self {
            self.timestamp_ns = Some(value);
            self
        }
    
        /// Set the `position_x` field
        #[must_use]
        pub fn position_x(mut self, value: f32) -> Self {
            self.position_x = Some(value);
            self
        }
    
        /// Set the `position_y` field
        #[must_use]
        pub fn position_y(mut self, value: f32) -> Self {
            self.position_y = Some(value);
            self
        }
    
        /// Set the `position_z` field
        #[must_use]
        pub fn position_z(mut self, value: f32) -> Self {
            self.position_z = Some(value);
            self
        }
    
        /// Set the `orientation_w` field
        #[must_use]
        pub fn orientation_w(mut self, value: f32) -> Self {
            self.orientation_w = Some(value);
            self
        }
    
        /// Set the `orientation_x` field
        #[must_use]
        pub fn orientation_x(mut self, value: f32) -> Self {
            self.orientation_x = Some(value);
            self
        }
    
        /// Set the `orientation_y` field
        #[must_use]
        pub fn orientation_y(mut self, value: f32) -> Self {
            self.orientation_y = Some(value);
            self
        }
    
        /// Set the `orientation_z` field
        #[must_use]
        pub fn orientation_z(mut self, value: f32) -> Self {
            self.orientation_z = Some(value);
            self
        }
    
        /// Set the `battery_percent` field
        #[must_use]
        pub fn battery_percent(mut self, value: f32) -> Self {
            self.battery_percent = Some(value);
            self
        }
    
        /// Set the `status` field
        #[must_use]
        pub fn status(mut self, value: u8) -> Self {
            self.status = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<RobotState, &'static str> {
            Ok(RobotState {
                robot_id: self.robot_id.ok_or("robot_id is required")?,
                timestamp_ns: self.timestamp_ns.ok_or("timestamp_ns is required")?,
                position_x: self.position_x.ok_or("position_x is required")?,
                position_y: self.position_y.ok_or("position_y is required")?,
                position_z: self.position_z.ok_or("position_z is required")?,
                orientation_w: self.orientation_w.ok_or("orientation_w is required")?,
                orientation_x: self.orientation_x.ok_or("orientation_x is required")?,
                orientation_y: self.orientation_y.ok_or("orientation_y is required")?,
                orientation_z: self.orientation_z.ok_or("orientation_z is required")?,
                battery_percent: self.battery_percent.ok_or("battery_percent is required")?,
                status: self.status.ok_or("status is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct RobotCommand {
        pub robot_id: u32,
        pub command_id: u64,
        pub target_x: f32,
        pub target_y: f32,
        pub target_z: f32,
        pub max_velocity: f32,
        pub command_type: u8,
    }
    
    impl Cdr2Encode for RobotCommand {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'robot_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.robot_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'command_id'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.command_id.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'target_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.target_x.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'target_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.target_y.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'target_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.target_z.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'max_velocity'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.max_velocity.to_le_bytes());
            offset += 4;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.command_type;
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 1
        }
    }
    
    impl Cdr2Decode for RobotCommand {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'robot_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let robot_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'command_id'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let command_id = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'target_x'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let target_x = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'target_y'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let target_y = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'target_z'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let target_z = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'max_velocity'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let max_velocity = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let command_type = src[offset];
            offset += 1;
    
            Ok((Self {
                robot_id,
                command_id,
                target_x,
                target_y,
                target_z,
                max_velocity,
                command_type,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for RobotCommand {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x08DBCBED,  // FNV-1a hash of "robotics::RobotCommand"
                    type_name: "robotics::RobotCommand",
                    size_bytes: 40,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "robot_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "command_id",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "target_x",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "target_y",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "target_z",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "max_velocity",
                            offset_bytes: 28,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "command_type",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("robotics::RobotCommand"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("robot_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("command_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("target_x"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("target_y"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("target_z"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("max_velocity"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("command_type"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl RobotCommand {
        /// Create a builder for RobotCommand
        #[must_use]
        pub fn builder() -> RobotCommandBuilder {
            RobotCommandBuilder::default()
        }
    }
    
    /// Builder for [RobotCommand]
    #[derive(Default)]
    pub struct RobotCommandBuilder {
        robot_id: Option<u32>,
        command_id: Option<u64>,
        target_x: Option<f32>,
        target_y: Option<f32>,
        target_z: Option<f32>,
        max_velocity: Option<f32>,
        command_type: Option<u8>,
    }
    
    impl RobotCommandBuilder {
        /// Set the `robot_id` field
        #[must_use]
        pub fn robot_id(mut self, value: u32) -> Self {
            self.robot_id = Some(value);
            self
        }
    
        /// Set the `command_id` field
        #[must_use]
        pub fn command_id(mut self, value: u64) -> Self {
            self.command_id = Some(value);
            self
        }
    
        /// Set the `target_x` field
        #[must_use]
        pub fn target_x(mut self, value: f32) -> Self {
            self.target_x = Some(value);
            self
        }
    
        /// Set the `target_y` field
        #[must_use]
        pub fn target_y(mut self, value: f32) -> Self {
            self.target_y = Some(value);
            self
        }
    
        /// Set the `target_z` field
        #[must_use]
        pub fn target_z(mut self, value: f32) -> Self {
            self.target_z = Some(value);
            self
        }
    
        /// Set the `max_velocity` field
        #[must_use]
        pub fn max_velocity(mut self, value: f32) -> Self {
            self.max_velocity = Some(value);
            self
        }
    
        /// Set the `command_type` field
        #[must_use]
        pub fn command_type(mut self, value: u8) -> Self {
            self.command_type = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<RobotCommand, &'static str> {
            Ok(RobotCommand {
                robot_id: self.robot_id.ok_or("robot_id is required")?,
                command_id: self.command_id.ok_or("command_id is required")?,
                target_x: self.target_x.ok_or("target_x is required")?,
                target_y: self.target_y.ok_or("target_y is required")?,
                target_z: self.target_z.ok_or("target_z is required")?,
                max_velocity: self.max_velocity.ok_or("max_velocity is required")?,
                command_type: self.command_type.ok_or("command_type is required")?,
            })
        }
    }
    
    }

pub mod iot {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct SensorReading {
        pub sensor_id: u32,
        pub timestamp: u64,
        pub temperature: f32,
        pub humidity: f32,
        pub pressure: f32,
        pub battery_voltage: f32,
        pub signal_strength: u8,
    }
    
    impl Cdr2Encode for SensorReading {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sensor_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.sensor_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'temperature'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.temperature.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'humidity'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.humidity.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'pressure'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.pressure.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'battery_voltage'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.battery_voltage.to_le_bytes());
            offset += 4;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.signal_strength;
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 1
        }
    }
    
    impl Cdr2Decode for SensorReading {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sensor_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let sensor_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'temperature'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let temperature = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'humidity'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let humidity = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'pressure'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let pressure = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'battery_voltage'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let battery_voltage = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let signal_strength = src[offset];
            offset += 1;
    
            Ok((Self {
                sensor_id,
                timestamp,
                temperature,
                humidity,
                pressure,
                battery_voltage,
                signal_strength,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for SensorReading {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x30C4CC1F,  // FNV-1a hash of "iot::SensorReading"
                    type_name: "iot::SensorReading",
                    size_bytes: 40,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "sensor_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "temperature",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "humidity",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "pressure",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "battery_voltage",
                            offset_bytes: 28,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "signal_strength",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("iot::SensorReading"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("sensor_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("temperature"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("humidity"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("pressure"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("battery_voltage"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("signal_strength"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // FNV-1a hash of @key fields
                let mut hash: u64 = 14695981039346656037;
                const PRIME: u64 = 1099511628211;
    
                // Hash @key field: sensor_id
                let bytes = self.sensor_id.to_le_bytes();
                for b in bytes {
                    hash ^= b as u64;
                    hash = hash.wrapping_mul(PRIME);
                }
    
                // Expand to 16 bytes
                let mut key = [0u8; 16];
                key[..8].copy_from_slice(&hash.to_le_bytes());
                hash = hash.wrapping_mul(PRIME);
                key[8..].copy_from_slice(&hash.to_le_bytes());
                key
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { true }
        }
        
    impl SensorReading {
        /// Create a builder for SensorReading
        #[must_use]
        pub fn builder() -> SensorReadingBuilder {
            SensorReadingBuilder::default()
        }
    }
    
    /// Builder for [SensorReading]
    #[derive(Default)]
    pub struct SensorReadingBuilder {
        sensor_id: Option<u32>,
        timestamp: Option<u64>,
        temperature: Option<f32>,
        humidity: Option<f32>,
        pressure: Option<f32>,
        battery_voltage: Option<f32>,
        signal_strength: Option<u8>,
    }
    
    impl SensorReadingBuilder {
        /// Set the `sensor_id` field
        #[must_use]
        pub fn sensor_id(mut self, value: u32) -> Self {
            self.sensor_id = Some(value);
            self
        }
    
        /// Set the `timestamp` field
        #[must_use]
        pub fn timestamp(mut self, value: u64) -> Self {
            self.timestamp = Some(value);
            self
        }
    
        /// Set the `temperature` field
        #[must_use]
        pub fn temperature(mut self, value: f32) -> Self {
            self.temperature = Some(value);
            self
        }
    
        /// Set the `humidity` field
        #[must_use]
        pub fn humidity(mut self, value: f32) -> Self {
            self.humidity = Some(value);
            self
        }
    
        /// Set the `pressure` field
        #[must_use]
        pub fn pressure(mut self, value: f32) -> Self {
            self.pressure = Some(value);
            self
        }
    
        /// Set the `battery_voltage` field
        #[must_use]
        pub fn battery_voltage(mut self, value: f32) -> Self {
            self.battery_voltage = Some(value);
            self
        }
    
        /// Set the `signal_strength` field
        #[must_use]
        pub fn signal_strength(mut self, value: u8) -> Self {
            self.signal_strength = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<SensorReading, &'static str> {
            Ok(SensorReading {
                sensor_id: self.sensor_id.ok_or("sensor_id is required")?,
                timestamp: self.timestamp.ok_or("timestamp is required")?,
                temperature: self.temperature.ok_or("temperature is required")?,
                humidity: self.humidity.ok_or("humidity is required")?,
                pressure: self.pressure.ok_or("pressure is required")?,
                battery_voltage: self.battery_voltage.ok_or("battery_voltage is required")?,
                signal_strength: self.signal_strength.ok_or("signal_strength is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct SensorAlert {
        pub sensor_id: u32,
        pub timestamp: u64,
        pub alert_code: u16,
        pub severity: u8,
        pub threshold: f32,
        pub actual_value: f32,
    }
    
    impl Cdr2Encode for SensorAlert {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sensor_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.sensor_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp.to_le_bytes());
            offset += 8;
    
            // Align to 2-byte boundary for field 'alert_code'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if dst.len() < offset + 2 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+2].copy_from_slice(&self.alert_code.to_le_bytes());
            offset += 2;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.severity;
            offset += 1;
    
            // Align to 4-byte boundary for field 'threshold'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.threshold.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'actual_value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.actual_value.to_le_bytes());
            offset += 4;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 1 + 2 + 1 + 3 + 4 + 3 + 4
        }
    }
    
    impl Cdr2Decode for SensorAlert {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'sensor_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let sensor_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 2-byte boundary for field 'alert_code'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if src.len() < offset + 2 {
                return Err(CdrError::UnexpectedEof);
            }
            let alert_code = {
                let mut __hdds_tmp = [0u8; 2];
                __hdds_tmp.copy_from_slice(&src[offset..offset+2]);
                u16::from_le_bytes(__hdds_tmp)
            };
            offset += 2;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let severity = src[offset];
            offset += 1;
    
            // Align to 4-byte boundary for field 'threshold'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let threshold = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'actual_value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let actual_value = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            Ok((Self {
                sensor_id,
                timestamp,
                alert_code,
                severity,
                threshold,
                actual_value,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for SensorAlert {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x57043FC5,  // FNV-1a hash of "iot::SensorAlert"
                    type_name: "iot::SensorAlert",
                    size_bytes: 32,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "sensor_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "alert_code",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U16
                            ),
                            alignment: 2,
                            size_bytes: 2,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "severity",
                            offset_bytes: 18,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "threshold",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "actual_value",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("iot::SensorAlert"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("sensor_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT16,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("alert_code"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("severity"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("threshold"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("actual_value"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl SensorAlert {
        /// Create a builder for SensorAlert
        #[must_use]
        pub fn builder() -> SensorAlertBuilder {
            SensorAlertBuilder::default()
        }
    }
    
    /// Builder for [SensorAlert]
    #[derive(Default)]
    pub struct SensorAlertBuilder {
        sensor_id: Option<u32>,
        timestamp: Option<u64>,
        alert_code: Option<u16>,
        severity: Option<u8>,
        threshold: Option<f32>,
        actual_value: Option<f32>,
    }
    
    impl SensorAlertBuilder {
        /// Set the `sensor_id` field
        #[must_use]
        pub fn sensor_id(mut self, value: u32) -> Self {
            self.sensor_id = Some(value);
            self
        }
    
        /// Set the `timestamp` field
        #[must_use]
        pub fn timestamp(mut self, value: u64) -> Self {
            self.timestamp = Some(value);
            self
        }
    
        /// Set the `alert_code` field
        #[must_use]
        pub fn alert_code(mut self, value: u16) -> Self {
            self.alert_code = Some(value);
            self
        }
    
        /// Set the `severity` field
        #[must_use]
        pub fn severity(mut self, value: u8) -> Self {
            self.severity = Some(value);
            self
        }
    
        /// Set the `threshold` field
        #[must_use]
        pub fn threshold(mut self, value: f32) -> Self {
            self.threshold = Some(value);
            self
        }
    
        /// Set the `actual_value` field
        #[must_use]
        pub fn actual_value(mut self, value: f32) -> Self {
            self.actual_value = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<SensorAlert, &'static str> {
            Ok(SensorAlert {
                sensor_id: self.sensor_id.ok_or("sensor_id is required")?,
                timestamp: self.timestamp.ok_or("timestamp is required")?,
                alert_code: self.alert_code.ok_or("alert_code is required")?,
                severity: self.severity.ok_or("severity is required")?,
                threshold: self.threshold.ok_or("threshold is required")?,
                actual_value: self.actual_value.ok_or("actual_value is required")?,
            })
        }
    }
    
    }

pub mod automotive {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct VehicleTelemetry {
        pub vehicle_id: u32,
        pub timestamp_ms: u64,
        pub latitude: f64,
        pub longitude: f64,
        pub speed_mps: f32,
        pub heading_deg: f32,
        pub acceleration: f32,
        pub brake_status: u8,
    }
    
    impl Cdr2Encode for VehicleTelemetry {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'vehicle_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.vehicle_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ms'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp_ms.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'latitude'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.latitude.to_le_bytes());
            offset += 8;
    
            // Align to 8-byte boundary for field 'longitude'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.longitude.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'speed_mps'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.speed_mps.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'heading_deg'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.heading_deg.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'acceleration'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.acceleration.to_le_bytes());
            offset += 4;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.brake_status;
            offset += 1;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 7 + 8 + 7 + 8 + 3 + 4 + 3 + 4 + 3 + 4 + 1
        }
    }
    
    impl Cdr2Decode for VehicleTelemetry {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'vehicle_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let vehicle_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ms'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp_ms = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'latitude'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let latitude = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 8-byte boundary for field 'longitude'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let longitude = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                f64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'speed_mps'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let speed_mps = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'heading_deg'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let heading_deg = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'acceleration'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let acceleration = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let brake_status = src[offset];
            offset += 1;
    
            Ok((Self {
                vehicle_id,
                timestamp_ms,
                latitude,
                longitude,
                speed_mps,
                heading_deg,
                acceleration,
                brake_status,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for VehicleTelemetry {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x56B4A65B,  // FNV-1a hash of "automotive::VehicleTelemetry"
                    type_name: "automotive::VehicleTelemetry",
                    size_bytes: 48,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "vehicle_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp_ms",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "latitude",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "longitude",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "speed_mps",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "heading_deg",
                            offset_bytes: 36,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "acceleration",
                            offset_bytes: 40,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "brake_status",
                            offset_bytes: 44,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("automotive::VehicleTelemetry"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("vehicle_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp_ms"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("latitude"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("longitude"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("speed_mps"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("heading_deg"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("acceleration"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 7,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("brake_status"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // FNV-1a hash of @key fields
                let mut hash: u64 = 14695981039346656037;
                const PRIME: u64 = 1099511628211;
    
                // Hash @key field: vehicle_id
                let bytes = self.vehicle_id.to_le_bytes();
                for b in bytes {
                    hash ^= b as u64;
                    hash = hash.wrapping_mul(PRIME);
                }
    
                // Expand to 16 bytes
                let mut key = [0u8; 16];
                key[..8].copy_from_slice(&hash.to_le_bytes());
                hash = hash.wrapping_mul(PRIME);
                key[8..].copy_from_slice(&hash.to_le_bytes());
                key
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { true }
        }
        
    impl VehicleTelemetry {
        /// Create a builder for VehicleTelemetry
        #[must_use]
        pub fn builder() -> VehicleTelemetryBuilder {
            VehicleTelemetryBuilder::default()
        }
    }
    
    /// Builder for [VehicleTelemetry]
    #[derive(Default)]
    pub struct VehicleTelemetryBuilder {
        vehicle_id: Option<u32>,
        timestamp_ms: Option<u64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        speed_mps: Option<f32>,
        heading_deg: Option<f32>,
        acceleration: Option<f32>,
        brake_status: Option<u8>,
    }
    
    impl VehicleTelemetryBuilder {
        /// Set the `vehicle_id` field
        #[must_use]
        pub fn vehicle_id(mut self, value: u32) -> Self {
            self.vehicle_id = Some(value);
            self
        }
    
        /// Set the `timestamp_ms` field
        #[must_use]
        pub fn timestamp_ms(mut self, value: u64) -> Self {
            self.timestamp_ms = Some(value);
            self
        }
    
        /// Set the `latitude` field
        #[must_use]
        pub fn latitude(mut self, value: f64) -> Self {
            self.latitude = Some(value);
            self
        }
    
        /// Set the `longitude` field
        #[must_use]
        pub fn longitude(mut self, value: f64) -> Self {
            self.longitude = Some(value);
            self
        }
    
        /// Set the `speed_mps` field
        #[must_use]
        pub fn speed_mps(mut self, value: f32) -> Self {
            self.speed_mps = Some(value);
            self
        }
    
        /// Set the `heading_deg` field
        #[must_use]
        pub fn heading_deg(mut self, value: f32) -> Self {
            self.heading_deg = Some(value);
            self
        }
    
        /// Set the `acceleration` field
        #[must_use]
        pub fn acceleration(mut self, value: f32) -> Self {
            self.acceleration = Some(value);
            self
        }
    
        /// Set the `brake_status` field
        #[must_use]
        pub fn brake_status(mut self, value: u8) -> Self {
            self.brake_status = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<VehicleTelemetry, &'static str> {
            Ok(VehicleTelemetry {
                vehicle_id: self.vehicle_id.ok_or("vehicle_id is required")?,
                timestamp_ms: self.timestamp_ms.ok_or("timestamp_ms is required")?,
                latitude: self.latitude.ok_or("latitude is required")?,
                longitude: self.longitude.ok_or("longitude is required")?,
                speed_mps: self.speed_mps.ok_or("speed_mps is required")?,
                heading_deg: self.heading_deg.ok_or("heading_deg is required")?,
                acceleration: self.acceleration.ok_or("acceleration is required")?,
                brake_status: self.brake_status.ok_or("brake_status is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct SignalPhase {
        pub intersection_id: u32,
        pub timestamp_ms: u64,
        pub phase: u8,
        pub time_to_change_ds: u16,
    }
    
    impl Cdr2Encode for SignalPhase {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'intersection_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.intersection_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ms'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp_ms.to_le_bytes());
            offset += 8;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.phase;
            offset += 1;
    
            // Align to 2-byte boundary for field 'time_to_change_ds'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if dst.len() < offset + 2 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+2].copy_from_slice(&self.time_to_change_ds.to_le_bytes());
            offset += 2;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 1 + 1 + 2
        }
    }
    
    impl Cdr2Decode for SignalPhase {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'intersection_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let intersection_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp_ms'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp_ms = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let phase = src[offset];
            offset += 1;
    
            // Align to 2-byte boundary for field 'time_to_change_ds'
            let padding = (2 - (offset % 2)) % 2;
            offset += padding;
    
            if src.len() < offset + 2 {
                return Err(CdrError::UnexpectedEof);
            }
            let time_to_change_ds = {
                let mut __hdds_tmp = [0u8; 2];
                __hdds_tmp.copy_from_slice(&src[offset..offset+2]);
                u16::from_le_bytes(__hdds_tmp)
            };
            offset += 2;
    
            Ok((Self {
                intersection_id,
                timestamp_ms,
                phase,
                time_to_change_ds,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for SignalPhase {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xC333B787,  // FNV-1a hash of "automotive::SignalPhase"
                    type_name: "automotive::SignalPhase",
                    size_bytes: 24,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "intersection_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp_ms",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "phase",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "time_to_change_ds",
                            offset_bytes: 18,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U16
                            ),
                            alignment: 2,
                            size_bytes: 2,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("automotive::SignalPhase"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("intersection_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp_ms"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("phase"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT16,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("time_to_change_ds"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl SignalPhase {
        /// Create a builder for SignalPhase
        #[must_use]
        pub fn builder() -> SignalPhaseBuilder {
            SignalPhaseBuilder::default()
        }
    }
    
    /// Builder for [SignalPhase]
    #[derive(Default)]
    pub struct SignalPhaseBuilder {
        intersection_id: Option<u32>,
        timestamp_ms: Option<u64>,
        phase: Option<u8>,
        time_to_change_ds: Option<u16>,
    }
    
    impl SignalPhaseBuilder {
        /// Set the `intersection_id` field
        #[must_use]
        pub fn intersection_id(mut self, value: u32) -> Self {
            self.intersection_id = Some(value);
            self
        }
    
        /// Set the `timestamp_ms` field
        #[must_use]
        pub fn timestamp_ms(mut self, value: u64) -> Self {
            self.timestamp_ms = Some(value);
            self
        }
    
        /// Set the `phase` field
        #[must_use]
        pub fn phase(mut self, value: u8) -> Self {
            self.phase = Some(value);
            self
        }
    
        /// Set the `time_to_change_ds` field
        #[must_use]
        pub fn time_to_change_ds(mut self, value: u16) -> Self {
            self.time_to_change_ds = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<SignalPhase, &'static str> {
            Ok(SignalPhase {
                intersection_id: self.intersection_id.ok_or("intersection_id is required")?,
                timestamp_ms: self.timestamp_ms.ok_or("timestamp_ms is required")?,
                phase: self.phase.ok_or("phase is required")?,
                time_to_change_ds: self.time_to_change_ds.ok_or("time_to_change_ds is required")?,
            })
        }
    }
    
    }

pub mod industrial {
    use super::*;

    #[derive(Debug, Clone, PartialEq)]
    pub struct ProcessData {
        pub plc_id: u32,
        pub timestamp: u64,
        pub tank_level: f32,
        pub flow_rate: f32,
        pub temperature: f32,
        pub pressure: f32,
        pub pump_status: u32,
        pub valve_status: u32,
    }
    
    impl Cdr2Encode for ProcessData {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'plc_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.plc_id.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.timestamp.to_le_bytes());
            offset += 8;
    
            // Align to 4-byte boundary for field 'tank_level'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.tank_level.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'flow_rate'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.flow_rate.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'temperature'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.temperature.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'pressure'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.pressure.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'pump_status'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.pump_status.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'valve_status'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.valve_status.to_le_bytes());
            offset += 4;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4 + 3 + 4
        }
    }
    
    impl Cdr2Decode for ProcessData {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'plc_id'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let plc_id = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'timestamp'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let timestamp = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            // Align to 4-byte boundary for field 'tank_level'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let tank_level = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'flow_rate'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let flow_rate = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'temperature'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let temperature = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'pressure'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let pressure = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'pump_status'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let pump_status = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'valve_status'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let valve_status = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            Ok((Self {
                plc_id,
                timestamp,
                tank_level,
                flow_rate,
                temperature,
                pressure,
                pump_status,
                valve_status,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for ProcessData {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0x853EB2C3,  // FNV-1a hash of "industrial::ProcessData"
                    type_name: "industrial::ProcessData",
                    size_bytes: 40,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "plc_id",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "timestamp",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "tank_level",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "flow_rate",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "temperature",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "pressure",
                            offset_bytes: 28,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "pump_status",
                            offset_bytes: 32,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "valve_status",
                            offset_bytes: 36,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("industrial::ProcessData"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("plc_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("timestamp"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("tank_level"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("flow_rate"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("temperature"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 5,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("pressure"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 6,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("pump_status"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 7,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("valve_status"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // FNV-1a hash of @key fields
                let mut hash: u64 = 14695981039346656037;
                const PRIME: u64 = 1099511628211;
    
                // Hash @key field: plc_id
                let bytes = self.plc_id.to_le_bytes();
                for b in bytes {
                    hash ^= b as u64;
                    hash = hash.wrapping_mul(PRIME);
                }
    
                // Expand to 16 bytes
                let mut key = [0u8; 16];
                key[..8].copy_from_slice(&hash.to_le_bytes());
                hash = hash.wrapping_mul(PRIME);
                key[8..].copy_from_slice(&hash.to_le_bytes());
                key
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { true }
        }
        
    impl ProcessData {
        /// Create a builder for ProcessData
        #[must_use]
        pub fn builder() -> ProcessDataBuilder {
            ProcessDataBuilder::default()
        }
    }
    
    /// Builder for [ProcessData]
    #[derive(Default)]
    pub struct ProcessDataBuilder {
        plc_id: Option<u32>,
        timestamp: Option<u64>,
        tank_level: Option<f32>,
        flow_rate: Option<f32>,
        temperature: Option<f32>,
        pressure: Option<f32>,
        pump_status: Option<u32>,
        valve_status: Option<u32>,
    }
    
    impl ProcessDataBuilder {
        /// Set the `plc_id` field
        #[must_use]
        pub fn plc_id(mut self, value: u32) -> Self {
            self.plc_id = Some(value);
            self
        }
    
        /// Set the `timestamp` field
        #[must_use]
        pub fn timestamp(mut self, value: u64) -> Self {
            self.timestamp = Some(value);
            self
        }
    
        /// Set the `tank_level` field
        #[must_use]
        pub fn tank_level(mut self, value: f32) -> Self {
            self.tank_level = Some(value);
            self
        }
    
        /// Set the `flow_rate` field
        #[must_use]
        pub fn flow_rate(mut self, value: f32) -> Self {
            self.flow_rate = Some(value);
            self
        }
    
        /// Set the `temperature` field
        #[must_use]
        pub fn temperature(mut self, value: f32) -> Self {
            self.temperature = Some(value);
            self
        }
    
        /// Set the `pressure` field
        #[must_use]
        pub fn pressure(mut self, value: f32) -> Self {
            self.pressure = Some(value);
            self
        }
    
        /// Set the `pump_status` field
        #[must_use]
        pub fn pump_status(mut self, value: u32) -> Self {
            self.pump_status = Some(value);
            self
        }
    
        /// Set the `valve_status` field
        #[must_use]
        pub fn valve_status(mut self, value: u32) -> Self {
            self.valve_status = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<ProcessData, &'static str> {
            Ok(ProcessData {
                plc_id: self.plc_id.ok_or("plc_id is required")?,
                timestamp: self.timestamp.ok_or("timestamp is required")?,
                tank_level: self.tank_level.ok_or("tank_level is required")?,
                flow_rate: self.flow_rate.ok_or("flow_rate is required")?,
                temperature: self.temperature.ok_or("temperature is required")?,
                pressure: self.pressure.ok_or("pressure is required")?,
                pump_status: self.pump_status.ok_or("pump_status is required")?,
                valve_status: self.valve_status.ok_or("valve_status is required")?,
            })
        }
    }
    
        #[derive(Debug, Clone, PartialEq)]
    pub struct ControlCommand {
        pub target_plc: u32,
        pub command_id: u64,
        pub command_type: u8,
        pub target_device: u32,
        pub value: f32,
    }
    
    impl Cdr2Encode for ControlCommand {
        fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'target_plc'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.target_plc.to_le_bytes());
            offset += 4;
    
            // Align to 8-byte boundary for field 'command_id'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if dst.len() < offset + 8 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+8].copy_from_slice(&self.command_id.to_le_bytes());
            offset += 8;
    
            if dst.len() < offset + 1 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset] = self.command_type;
            offset += 1;
    
            // Align to 4-byte boundary for field 'target_device'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.target_device.to_le_bytes());
            offset += 4;
    
            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if dst.len() < offset + 4 {
                return Err(CdrError::BufferTooSmall);
            }
            dst[offset..offset+4].copy_from_slice(&self.value.to_le_bytes());
            offset += 4;
    
            Ok(offset)
        }
    
        fn max_cdr2_size(&self) -> usize {
            // Conservative estimate with max padding
            3 + 4 + 7 + 8 + 1 + 3 + 4 + 3 + 4
        }
    }
    
    impl Cdr2Decode for ControlCommand {
        fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
            let mut offset: usize = 0;
    
            // Align to 4-byte boundary for field 'target_plc'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let target_plc = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 8-byte boundary for field 'command_id'
            let padding = (8 - (offset % 8)) % 8;
            offset += padding;
    
            if src.len() < offset + 8 {
                return Err(CdrError::UnexpectedEof);
            }
            let command_id = {
                let mut __hdds_tmp = [0u8; 8];
                __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
                u64::from_le_bytes(__hdds_tmp)
            };
            offset += 8;
    
            if src.len() < offset + 1 {
                return Err(CdrError::UnexpectedEof);
            }
            let command_type = src[offset];
            offset += 1;
    
            // Align to 4-byte boundary for field 'target_device'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let target_device = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                u32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            // Align to 4-byte boundary for field 'value'
            let padding = (4 - (offset % 4)) % 4;
            offset += padding;
    
            if src.len() < offset + 4 {
                return Err(CdrError::UnexpectedEof);
            }
            let value = {
                let mut __hdds_tmp = [0u8; 4];
                __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
                f32::from_le_bytes(__hdds_tmp)
            };
            offset += 4;
    
            Ok((Self {
                target_plc,
                command_id,
                command_type,
                target_device,
                value,
            }, offset))
        }
    }
    
        // === DDS Trait (auto-generated by idl-gen) ===
        impl ::hdds::api::DDS for ControlCommand {
            fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
                static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
                    type_id: 0xF6429368,  // FNV-1a hash of "industrial::ControlCommand"
                    type_name: "industrial::ControlCommand",
                    size_bytes: 32,
                    alignment: 8,
                    is_variable_size: false,
                    fields: &[
                        ::hdds::core::types::FieldLayout {
                            name: "target_plc",
                            offset_bytes: 0,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "command_id",
                            offset_bytes: 8,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U64
                            ),
                            alignment: 8,
                            size_bytes: 8,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "command_type",
                            offset_bytes: 16,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U8
                            ),
                            alignment: 1,
                            size_bytes: 1,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "target_device",
                            offset_bytes: 20,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::U32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                        ::hdds::core::types::FieldLayout {
                            name: "value",
                            offset_bytes: 24,
                            field_type: ::hdds::core::types::FieldType::Primitive(
                                ::hdds::core::types::PrimitiveKind::F32
                            ),
                            alignment: 4,
                            size_bytes: 4,
                            element_type: None,
                        },
                    ],
                };
                &DESC
            }
    
            fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
                use ::hdds::core::ser::Cdr2Encode;
                self.encode_cdr2_le(buf).map_err(Into::into)
            }
    
            fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
                use ::hdds::core::ser::Cdr2Decode;
                Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
            }
    
            fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
                Some(::hdds::xtypes::CompleteTypeObject::Struct(
                    ::hdds::xtypes::CompleteStructType {
                        struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                        header: ::hdds::xtypes::CompleteStructHeader {
                            base_type: None,
                            detail: ::hdds::xtypes::CompleteTypeDetail::new("industrial::ControlCommand"),
                        },
                        member_seq: vec![
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 0,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("target_plc"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 1,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT64,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("command_id"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 2,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_BYTE,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("command_type"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 3,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("target_device"),
                            },
                            ::hdds::xtypes::CompleteStructMember {
                                common: ::hdds::xtypes::CommonStructMember {
                                    member_id: 4,
                                    member_flags: ::hdds::xtypes::MemberFlag::empty(),
                                    member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                                },
                                detail: ::hdds::xtypes::CompleteMemberDetail::new("value"),
                            },
                        ],
                    }
                ))
            }
    
            /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
            fn compute_key(&self) -> [u8; 16] {
                // No @key fields - return zeroed hash
                [0u8; 16]
            }
    
            /// Returns true if this type has @key fields
            fn has_key() -> bool { false }
        }
        
    impl ControlCommand {
        /// Create a builder for ControlCommand
        #[must_use]
        pub fn builder() -> ControlCommandBuilder {
            ControlCommandBuilder::default()
        }
    }
    
    /// Builder for [ControlCommand]
    #[derive(Default)]
    pub struct ControlCommandBuilder {
        target_plc: Option<u32>,
        command_id: Option<u64>,
        command_type: Option<u8>,
        target_device: Option<u32>,
        value: Option<f32>,
    }
    
    impl ControlCommandBuilder {
        /// Set the `target_plc` field
        #[must_use]
        pub fn target_plc(mut self, value: u32) -> Self {
            self.target_plc = Some(value);
            self
        }
    
        /// Set the `command_id` field
        #[must_use]
        pub fn command_id(mut self, value: u64) -> Self {
            self.command_id = Some(value);
            self
        }
    
        /// Set the `command_type` field
        #[must_use]
        pub fn command_type(mut self, value: u8) -> Self {
            self.command_type = Some(value);
            self
        }
    
        /// Set the `target_device` field
        #[must_use]
        pub fn target_device(mut self, value: u32) -> Self {
            self.target_device = Some(value);
            self
        }
    
        /// Set the `value` field
        #[must_use]
        pub fn value(mut self, value: f32) -> Self {
            self.value = Some(value);
            self
        }
    
        /// Build the struct, returning an error if required fields are missing
        pub fn build(self) -> Result<ControlCommand, &'static str> {
            Ok(ControlCommand {
                target_plc: self.target_plc.ok_or("target_plc is required")?,
                command_id: self.command_id.ok_or("command_id is required")?,
                command_type: self.command_type.ok_or("command_type is required")?,
                target_device: self.target_device.ok_or("target_device is required")?,
                value: self.value.ok_or("value is required")?,
            })
        }
    }
    
    }

