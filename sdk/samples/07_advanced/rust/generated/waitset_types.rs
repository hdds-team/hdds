// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by idl_parser v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

/// Simple message type for waitset demonstration
#[derive(Debug, Clone, PartialEq)]
pub struct Message {
    pub topic: String,
    pub sequence: u32,
    pub content: String,
}

impl Cdr2Encode for Message {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset: usize = 0;

        // Align to 4-byte boundary for field 'topic'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'topic'
        let bytes = self.topic.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        // Align to 4-byte boundary for field 'sequence'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if dst.len() < offset + 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&self.sequence.to_le_bytes());
        offset += 4;

        // Align to 4-byte boundary for field 'content'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'content'
        let bytes = self.content.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        // Conservative estimate with max padding
        3 + (4 + 256 + 1) + 3 + 4 + 3 + (4 + 256 + 1)
    }
}

impl Cdr2Decode for Message {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset: usize = 0;

        // Align to 4-byte boundary for field 'topic'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'topic'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let topic = s.to_string();
        offset += len + 1; // skip null terminator

        // Align to 4-byte boundary for field 'sequence'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let sequence = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp)
        };
        offset += 4;

        // Align to 4-byte boundary for field 'content'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'content'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let content = s.to_string();
        offset += len + 1; // skip null terminator

        Ok((Self {
            topic,
            sequence,
            content,
        }, offset))
    }
}

// === DDS Trait (auto-generated by idl-gen) ===
impl ::hdds::api::DDS for Message {
    fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
        static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
            type_id: 0xA1B2C3D4,  // FNV-1a hash of "Message"
            type_name: "Message",
            size_bytes: 24,
            alignment: 8,
            is_variable_size: true,
            fields: &[
                ::hdds::core::types::FieldLayout {
                    name: "topic",
                    offset_bytes: 0,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::String
                    ),
                    alignment: 8,
                    size_bytes: 8,
                    element_type: None,
                },
                ::hdds::core::types::FieldLayout {
                    name: "sequence",
                    offset_bytes: 8,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::U32
                    ),
                    alignment: 4,
                    size_bytes: 4,
                    element_type: None,
                },
                ::hdds::core::types::FieldLayout {
                    name: "content",
                    offset_bytes: 16,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::String
                    ),
                    alignment: 8,
                    size_bytes: 8,
                    element_type: None,
                },
            ],
        };
        &DESC
    }

    fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
        use ::hdds::core::ser::Cdr2Encode;
        self.encode_cdr2_le(buf).map_err(Into::into)
    }

    fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
        use ::hdds::core::ser::Cdr2Decode;
        Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
    }

    fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
        Some(::hdds::xtypes::CompleteTypeObject::Struct(
            ::hdds::xtypes::CompleteStructType {
                struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                header: ::hdds::xtypes::CompleteStructHeader {
                    base_type: None,
                    detail: ::hdds::xtypes::CompleteTypeDetail::new("Message"),
                },
                member_seq: vec![
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 0,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("topic"),
                    },
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 1,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("sequence"),
                    },
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 2,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("content"),
                    },
                ],
            }
        ))
    }

    /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
    fn compute_key(&self) -> [u8; 16] {
        // No @key fields - return zeroed hash
        [0u8; 16]
    }

    /// Returns true if this type has @key fields
    fn has_key() -> bool { false }
}

impl Message {
    /// Create a new Message instance.
    pub fn new(topic: impl Into<String>, sequence: u32, content: impl Into<String>) -> Self {
        Self {
            topic: topic.into(),
            sequence,
            content: content.into(),
        }
    }
}
