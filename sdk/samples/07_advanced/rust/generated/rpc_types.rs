// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by idl_parser v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

/// Request message for RPC pattern
#[derive(Debug, Clone, PartialEq)]
pub struct Request {
    pub request_id: u64,
    pub client_id: String,
    pub operation: String,
    pub payload: String,
}

impl Cdr2Encode for Request {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset: usize = 0;

        // Align to 8-byte boundary for field 'request_id'
        let padding = (8 - (offset % 8)) % 8;
        offset += padding;

        if dst.len() < offset + 8 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+8].copy_from_slice(&self.request_id.to_le_bytes());
        offset += 8;

        // Align to 4-byte boundary for field 'client_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'client_id'
        let bytes = self.client_id.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        // Align to 4-byte boundary for field 'operation'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'operation'
        let bytes = self.operation.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        // Align to 4-byte boundary for field 'payload'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'payload'
        let bytes = self.payload.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        7 + 8 + 3 + (4 + 256 + 1) + 3 + (4 + 256 + 1) + 3 + (4 + 1024 + 1)
    }
}

impl Cdr2Decode for Request {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset: usize = 0;

        // Align to 8-byte boundary for field 'request_id'
        let padding = (8 - (offset % 8)) % 8;
        offset += padding;

        if src.len() < offset + 8 {
            return Err(CdrError::UnexpectedEof);
        }
        let request_id = {
            let mut __hdds_tmp = [0u8; 8];
            __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
            u64::from_le_bytes(__hdds_tmp)
        };
        offset += 8;

        // Align to 4-byte boundary for field 'client_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'client_id'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let client_id = s.to_string();
        offset += len + 1;

        // Align to 4-byte boundary for field 'operation'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'operation'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let operation = s.to_string();
        offset += len + 1;

        // Align to 4-byte boundary for field 'payload'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'payload'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let payload = s.to_string();
        offset += len + 1;

        Ok((Self {
            request_id,
            client_id,
            operation,
            payload,
        }, offset))
    }
}

// === DDS Trait (auto-generated by idl-gen) ===
impl ::hdds::api::DDS for Request {
    fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
        static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
            type_id: 0xC1D2E3F4,
            type_name: "Request",
            size_bytes: 40,
            alignment: 8,
            is_variable_size: true,
            fields: &[],
        };
        &DESC
    }

    fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
        use ::hdds::core::ser::Cdr2Encode;
        self.encode_cdr2_le(buf).map_err(Into::into)
    }

    fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
        use ::hdds::core::ser::Cdr2Decode;
        Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
    }

    fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
        None
    }

    fn compute_key(&self) -> [u8; 16] {
        [0u8; 16]
    }

    fn has_key() -> bool { false }
}

impl Request {
    pub fn new(request_id: u64, client_id: impl Into<String>, operation: impl Into<String>, payload: impl Into<String>) -> Self {
        Self {
            request_id,
            client_id: client_id.into(),
            operation: operation.into(),
            payload: payload.into(),
        }
    }
}

/// Reply message for RPC pattern
#[derive(Debug, Clone, PartialEq)]
pub struct Reply {
    pub request_id: u64,
    pub client_id: String,
    pub status_code: i32,
    pub result: String,
}

impl Cdr2Encode for Reply {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset: usize = 0;

        // Align to 8-byte boundary for field 'request_id'
        let padding = (8 - (offset % 8)) % 8;
        offset += padding;

        if dst.len() < offset + 8 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+8].copy_from_slice(&self.request_id.to_le_bytes());
        offset += 8;

        // Align to 4-byte boundary for field 'client_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'client_id'
        let bytes = self.client_id.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        // Align to 4-byte boundary for field 'status_code'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if dst.len() < offset + 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&self.status_code.to_le_bytes());
        offset += 4;

        // Align to 4-byte boundary for field 'result'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'result'
        let bytes = self.result.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        7 + 8 + 3 + (4 + 256 + 1) + 3 + 4 + 3 + (4 + 1024 + 1)
    }
}

impl Cdr2Decode for Reply {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset: usize = 0;

        // Align to 8-byte boundary for field 'request_id'
        let padding = (8 - (offset % 8)) % 8;
        offset += padding;

        if src.len() < offset + 8 {
            return Err(CdrError::UnexpectedEof);
        }
        let request_id = {
            let mut __hdds_tmp = [0u8; 8];
            __hdds_tmp.copy_from_slice(&src[offset..offset+8]);
            u64::from_le_bytes(__hdds_tmp)
        };
        offset += 8;

        // Align to 4-byte boundary for field 'client_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'client_id'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let client_id = s.to_string();
        offset += len + 1;

        // Align to 4-byte boundary for field 'status_code'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let status_code = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            i32::from_le_bytes(__hdds_tmp)
        };
        offset += 4;

        // Align to 4-byte boundary for field 'result'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'result'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let result = s.to_string();
        offset += len + 1;

        Ok((Self {
            request_id,
            client_id,
            status_code,
            result,
        }, offset))
    }
}

// === DDS Trait (auto-generated by idl-gen) ===
impl ::hdds::api::DDS for Reply {
    fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
        static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
            type_id: 0xD1E2F3A4,
            type_name: "Reply",
            size_bytes: 32,
            alignment: 8,
            is_variable_size: true,
            fields: &[],
        };
        &DESC
    }

    fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
        use ::hdds::core::ser::Cdr2Encode;
        self.encode_cdr2_le(buf).map_err(Into::into)
    }

    fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
        use ::hdds::core::ser::Cdr2Decode;
        Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
    }

    fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
        None
    }

    fn compute_key(&self) -> [u8; 16] {
        [0u8; 16]
    }

    fn has_key() -> bool { false }
}

impl Reply {
    pub fn new(request_id: u64, client_id: impl Into<String>, status_code: i32, result: impl Into<String>) -> Self {
        Self {
            request_id,
            client_id: client_id.into(),
            status_code,
            result: result.into(),
        }
    }
}
