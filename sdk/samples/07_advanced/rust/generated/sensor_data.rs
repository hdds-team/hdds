// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (c) 2025-2026 naskel.com

// Generated by idl_parser v0.2.0
// DO NOT EDIT
// Compatible with include!() macro

use hdds::{Cdr2Encode, Cdr2Decode, CdrError};

/// Sensor data type for content filter demonstration
#[derive(Debug, Clone, PartialEq)]
pub struct SensorData {
    pub sensor_id: u32,
    pub location: String,
    pub temperature: f32,
    pub humidity: f32,
}

impl Cdr2Encode for SensorData {
    fn encode_cdr2_le(&self, dst: &mut [u8]) -> Result<usize, CdrError> {
        let mut offset: usize = 0;

        // Align to 4-byte boundary for field 'sensor_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if dst.len() < offset + 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&self.sensor_id.to_le_bytes());
        offset += 4;

        // Align to 4-byte boundary for field 'location'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Encode String field 'location'
        let bytes = self.location.as_bytes();
        let len = bytes.len();
        let len_u32 = u32::try_from(len).map_err(|_| CdrError::InvalidEncoding)?;
        if dst.len() < offset + 4 + len + 1 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&len_u32.to_le_bytes());
        offset += 4;
        dst[offset..offset+len].copy_from_slice(bytes);
        offset += len;
        dst[offset] = 0; // null terminator
        offset += 1;

        // Align to 4-byte boundary for field 'temperature'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if dst.len() < offset + 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&self.temperature.to_le_bytes());
        offset += 4;

        // Align to 4-byte boundary for field 'humidity'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if dst.len() < offset + 4 {
            return Err(CdrError::BufferTooSmall);
        }
        dst[offset..offset+4].copy_from_slice(&self.humidity.to_le_bytes());
        offset += 4;

        Ok(offset)
    }

    fn max_cdr2_size(&self) -> usize {
        // Conservative estimate with max padding
        3 + 4 + 3 + (4 + 256 + 1) + 3 + 4 + 3 + 4
    }
}

impl Cdr2Decode for SensorData {
    fn decode_cdr2_le(src: &[u8]) -> Result<(Self, usize), CdrError> {
        let mut offset: usize = 0;

        // Align to 4-byte boundary for field 'sensor_id'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let sensor_id = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp)
        };
        offset += 4;

        // Align to 4-byte boundary for field 'location'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        // Decode String field 'location'
        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let len = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            u32::from_le_bytes(__hdds_tmp) as usize
        };
        offset += 4;
        if src.len() < offset + len + 1 {
            return Err(CdrError::UnexpectedEof);
        }
        let s = std::str::from_utf8(&src[offset..offset+len])
            .map_err(|_| CdrError::InvalidEncoding)?;
        let location = s.to_string();
        offset += len + 1; // skip null terminator

        // Align to 4-byte boundary for field 'temperature'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let temperature = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            f32::from_le_bytes(__hdds_tmp)
        };
        offset += 4;

        // Align to 4-byte boundary for field 'humidity'
        let padding = (4 - (offset % 4)) % 4;
        offset += padding;

        if src.len() < offset + 4 {
            return Err(CdrError::UnexpectedEof);
        }
        let humidity = {
            let mut __hdds_tmp = [0u8; 4];
            __hdds_tmp.copy_from_slice(&src[offset..offset+4]);
            f32::from_le_bytes(__hdds_tmp)
        };
        offset += 4;

        Ok((Self {
            sensor_id,
            location,
            temperature,
            humidity,
        }, offset))
    }
}

// === DDS Trait (auto-generated by idl-gen) ===
impl ::hdds::api::DDS for SensorData {
    fn type_descriptor() -> &'static ::hdds::core::types::TypeDescriptor {
        static DESC: ::hdds::core::types::TypeDescriptor = ::hdds::core::types::TypeDescriptor {
            type_id: 0xB1C2D3E4,  // FNV-1a hash of "SensorData"
            type_name: "SensorData",
            size_bytes: 24,
            alignment: 8,
            is_variable_size: true,
            fields: &[
                ::hdds::core::types::FieldLayout {
                    name: "sensor_id",
                    offset_bytes: 0,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::U32
                    ),
                    alignment: 4,
                    size_bytes: 4,
                    element_type: None,
                },
                ::hdds::core::types::FieldLayout {
                    name: "location",
                    offset_bytes: 8,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::String
                    ),
                    alignment: 8,
                    size_bytes: 8,
                    element_type: None,
                },
                ::hdds::core::types::FieldLayout {
                    name: "temperature",
                    offset_bytes: 16,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::F32
                    ),
                    alignment: 4,
                    size_bytes: 4,
                    element_type: None,
                },
                ::hdds::core::types::FieldLayout {
                    name: "humidity",
                    offset_bytes: 20,
                    field_type: ::hdds::core::types::FieldType::Primitive(
                        ::hdds::core::types::PrimitiveKind::F32
                    ),
                    alignment: 4,
                    size_bytes: 4,
                    element_type: None,
                },
            ],
        };
        &DESC
    }

    fn encode_cdr2(&self, buf: &mut [u8]) -> ::hdds::api::Result<usize> {
        use ::hdds::core::ser::Cdr2Encode;
        self.encode_cdr2_le(buf).map_err(Into::into)
    }

    fn decode_cdr2(buf: &[u8]) -> ::hdds::api::Result<Self> {
        use ::hdds::core::ser::Cdr2Decode;
        Self::decode_cdr2_le(buf).map(|(val, _)| val).map_err(Into::into)
    }

    fn get_type_object() -> Option<::hdds::xtypes::CompleteTypeObject> {
        Some(::hdds::xtypes::CompleteTypeObject::Struct(
            ::hdds::xtypes::CompleteStructType {
                struct_flags: ::hdds::xtypes::StructTypeFlag::IS_FINAL,
                header: ::hdds::xtypes::CompleteStructHeader {
                    base_type: None,
                    detail: ::hdds::xtypes::CompleteTypeDetail::new("SensorData"),
                },
                member_seq: vec![
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 0,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_UINT32,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("sensor_id"),
                    },
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 1,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_STRING8,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("location"),
                    },
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 2,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("temperature"),
                    },
                    ::hdds::xtypes::CompleteStructMember {
                        common: ::hdds::xtypes::CommonStructMember {
                            member_id: 3,
                            member_flags: ::hdds::xtypes::MemberFlag::empty(),
                            member_type_id: ::hdds::xtypes::TypeIdentifier::TK_FLOAT32,
                        },
                        detail: ::hdds::xtypes::CompleteMemberDetail::new("humidity"),
                    },
                ],
            }
        ))
    }

    /// Compute instance key hash from @key fields (FNV-1a, 16 bytes)
    fn compute_key(&self) -> [u8; 16] {
        // No @key fields - return zeroed hash
        [0u8; 16]
    }

    /// Returns true if this type has @key fields
    fn has_key() -> bool { false }

    /// Get field values for content filtering
    fn get_fields(&self) -> std::collections::HashMap<String, ::hdds::FieldValue> {
        let mut fields = std::collections::HashMap::new();
        fields.insert("sensor_id".to_string(), ::hdds::FieldValue::from_u32(self.sensor_id));
        fields.insert("location".to_string(), ::hdds::FieldValue::from_string(&self.location));
        fields.insert("temperature".to_string(), ::hdds::FieldValue::from_f64(self.temperature as f64));
        fields.insert("humidity".to_string(), ::hdds::FieldValue::from_f64(self.humidity as f64));
        fields
    }
}

impl SensorData {
    /// Create a new SensorData instance.
    pub fn new(sensor_id: u32, location: impl Into<String>, temperature: f32, humidity: f32) -> Self {
        Self {
            sensor_id,
            location: location.into(),
            temperature,
            humidity,
        }
    }
}
