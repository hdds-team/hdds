# SPDX-License-Identifier: Apache-2.0 OR MIT
# Copyright (c) 2025-2026 naskel.com

"""
Generated by idl-gen v0.2.0
DO NOT EDIT

Python target (dataclasses + typing + CDR2 serialization)
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Union as UnionType, Tuple
from enum import IntEnum
import struct

@dataclass
class SensorData:
    """IDL: struct SensorData { uint64_t timestamp; uint32_t id; float value; }"""
    timestamp: int
    id: int
    value: float

    def encode_cdr2_le(self) -> bytes:
        """Encode to CDR2 little-endian format."""
        parts: List[bytes] = []
        offset = 0
        # align to 8 and pack timestamp
        pad = (8 - (offset % 8)) % 8
        parts.append(b'\x00' * pad)
        offset += pad
        parts.append(struct.pack('<Q', self.timestamp))
        offset += 8
        # align to 4 and pack id
        pad = (4 - (offset % 4)) % 4
        parts.append(b'\x00' * pad)
        offset += pad
        parts.append(struct.pack('<I', self.id))
        offset += 4
        # align to 4 and pack value
        pad = (4 - (offset % 4)) % 4
        parts.append(b'\x00' * pad)
        offset += pad
        parts.append(struct.pack('<f', self.value))
        offset += 4
        return b''.join(parts)

    @classmethod
    def decode_cdr2_le(cls, data: bytes) -> Tuple['SensorData', int]:
        """Decode from CDR2 little-endian format. Returns (instance, bytes_read)."""
        offset = 0
        # align and unpack timestamp
        offset += (8 - (offset % 8)) % 8
        _timestamp, = struct.unpack_from('<Q', data, offset)
        offset += 8
        # align and unpack id
        offset += (4 - (offset % 4)) % 4
        _id, = struct.unpack_from('<I', data, offset)
        offset += 4
        # align and unpack value
        offset += (4 - (offset % 4)) % 4
        _value, = struct.unpack_from('<f', data, offset)
        offset += 4
        return cls(timestamp=_timestamp, id=_id, value=_value), offset

    @classmethod
    def type_name(cls) -> str:
        """Return the DDS type name."""
        return "SensorData"

    def compute_key(self) -> bytes:
        """Compute instance key hash from @key fields (FNV-1a, 16 bytes)."""
        # No @key fields - return zeroed hash
        return bytes(16)

    @classmethod
    def has_key(cls) -> bool:
        """Return True if this type has @key fields."""
        return False

